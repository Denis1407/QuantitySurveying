<!DOCTYPE html>
 <html>
 <head>
     <meta charset="UTF-8" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Advanced 2D Drawing & 3D Quantifier</title>
     <script src="https://cdn.tailwindcss.com"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
     <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>

    <style>
        
        /* REPLACE all existing splash screen styles with these */
#splashScreen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    transition: opacity 0.8s ease-in-out;
}

#splash-background {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    transition: background-image 1s ease-in-out, opacity 1s ease-in-out;
    opacity: 0; /* Start hidden, will be faded in */
}

#splash-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: rgba(10, 10, 20, 0.7); /* Dark blueish overlay */
}

#splashContent {
    text-align: center;
    z-index: 1;
    position: relative;
    max-width: 400px;
}

#splashTitle {
    font-size: 4rem;
    font-weight: bold;
    color: #FFF;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    margin-bottom: 20px;
}

.progress-container {
    width: 100%;
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 5px;
    overflow: hidden;
    height: 8px;
    margin-bottom: 10px;
}

#progressBar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #4CAF50, #81C784);
    transition: width 3.5s cubic-bezier(0.25, 1, 0.5, 1); /* Smoother transition */
}

#splashMessage {
    font-size: 1rem;
    color: #E0E0E0;
    letter-spacing: 1px;
}

         html, body {
             margin: 0; padding: 0; background: #222; overflow: hidden;
             width: 100%; height: 100%; font-family: 'Inter', sans-serif;
         }
         #canvas {
             position: absolute; top: 0; left: 0; width: 100%; height: 100%;
             touch-action: none; cursor: crosshair; z-index: 0;
         }
         #threeDContainer {
             position: absolute; top: 0; left: 0; width: 100%; height: 100%;
             z-index: 1; visibility: hidden;
         }

         /* --- PASTE THIS NEW CODE IN ITS PLACE --- */

/* This new rule makes the ribbon full-width and attaches it to the top */
/* PASTE THIS FINAL CSS FOR THE TOP CONTROLS */

.top-interface-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
    display: flex;
    flex-direction: column;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}

.control-ribbon {
    display: flex;
    align-items: center;
    gap: 20px;
    padding: 5px 15px;
    background: rgba(45, 45, 45, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    flex-wrap: nowrap;
    overflow-x: auto;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.controls {
    display: flex;
    flex-wrap: nowrap; 
    gap: 6px; 
    align-items: center;
}

/* Add a separator between control groups */
.controls:not(:last-child) {
    padding-right: 20px;
    border-right: 1px solid rgba(255, 255, 255, 0.1);
}

#rebarControls { display: none; }
/* Add this line to your CSS */
input[type="file"] { display: none; }

.controls button, .controls select, .controls label {
    background-color: #4CAF50;
    border: 1px solid rgba(0,0,0,0.2);
    color: white;
    padding: 4px 8px; 
    display: inline-flex; 
    align-items: center;
    justify-content: center;
    font-size: 11px; 
    margin: 0; 
    cursor: pointer;
    border-radius: 5px;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.controls button:hover, .controls select:hover {
    background-color: #5dc461;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.controls label {
    background: transparent;
    border: none;
    padding: 4px;
}

/* Square icon buttons */
#projectControls button, #drawingControls button, #layerControls button, #mainActions button, #toolControls button {
    width: 28px;
    height: 28px;
    font-size: 13px;
}

.controls select {
    background-color: #007bff;
    padding-right: 25px; 
}

#smmDbStatus {
    font-size: 11px;
    margin-left: 5px;
    color: #f44336;
}

/* --- The rest of your original styles that were below the deleted block should remain. --- */
/* PASTE THIS NEW CSS IN ITS PLACE */

#info-panel-container {
    position: absolute;
    top: 80px;
    right: 10px;
    z-index: 5;
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 240px;
    /* Adjusted max-height to account for bottom ruler (55px) + margin (20px) */
    max-height: calc(100vh - 155px);
    overflow-y: auto;
}

/* ADD these custom scrollbar styles for better visibility */
#info-panel-container::-webkit-scrollbar {
    width: 10px;
}
#info-panel-container::-webkit-scrollbar-track {
    background: rgba(0,0,0,0.2);
    border-radius: 10px;
}
#info-panel-container::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 10px;
    border: 2px solid transparent;
    background-clip: content-box;
}
#info-panel-container::-webkit-scrollbar-thumb:hover {
    background: #777;
}

/* ADD THIS CSS to resize the buttons */
.info-box .modal-buttons button {
    padding: 5px 10px;
    font-size: 12px;
}

.info-box {
    background: rgba(34, 34, 34, 0.85);
    padding: 10px 15px;
    border-radius: 12px;
    color: white;
    box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.2);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

#layerListContainer { 
    max-height: 200px; 
    overflow-y: auto;
}

.info-box p { margin-bottom: 5px; font-size: 14px; }
.info-box h3 {
    margin-top: 0; margin-bottom: 10px; font-size: 16px; color: #4CAF50;
    border-bottom: 1px solid #4CAF50; padding-bottom: 5px;
}
.info-box h4 {
    margin-top: 10px; margin-bottom: 5px; font-size: 15px; color: #66BB6A;
}
.info-box ul {
    list-style: none; padding-left: 0; margin-top: 5px;
}
.info-box ul li {
    font-size: 13px; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between;
}
.info-box input[type="checkbox"] { margin-right: 10px; }
.modal-container {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
    display: flex; justify-content: center; align-items: center; z-index: 1000;
}
.modal-content {
    background: #333; padding: 25px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    color: white; text-align: left; max-width: 400px; width: 90%; border: 1px solid rgba(255,255,255,0.2);
}
.modal-content h3 { color: #4CAF50; margin-top: 0; }
.modal-content input, .modal-content select, .modal-content textarea {
    width: 100%; padding: 8px; margin-top: 5px; border-radius: 6px;
    border: 1px solid #555; background: #222; color: white;
}
.modal-buttons { display: flex; justify-content: space-around; margin-top: 20px; }
.modal-buttons button { width: auto; padding: 10px 15px; }
#tooltip, #angleIndicator {
    position: absolute; z-index: 100; background: rgba(0, 0, 0, 0.8); color: white;
    padding: 10px; border-radius: 5px; pointer-events: none; visibility: hidden;
    font-size: 12px; max-width: 300px;
}

        #loadProjectInput {display: none;}

        #projectControls {display: inline-block;}
        #drawingControls {display: inline-block;}
        #mainControls {display: inline-block;}
        #layerControls {float:inline-end;}

                /* Style for the clickable quantity values */
        .quantity-value {
            cursor: pointer;
            text-decoration: underline;
            font-weight: bold;
            color: #66BB6A;
            padding: 2px 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .quantity-value:hover {
            background-color: #555;
        }

        /* BOQ Modal Styles */
        .boq-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none; /* Hidden by default */
            justify-content: center; align-items: center; z-index: 1001;
        }
        .boq-content {
            background: #333; padding: 25px; border-radius: 12px;
            width: 80%; max-width: 900px; height: 70%;
            display: flex; flex-direction: column;
        }
        .boq-content h3 { color: #4CAF50; margin-top: 0; }
        .boq-table-container { flex-grow: 1; overflow-y: auto; }
        .boq-table { width: 100%; border-collapse: collapse; color: white; }
        .boq-table th, .boq-table td {
            border: 1px solid #555; padding: 8px; text-align: left;
        }
        .boq-table th { background-color: #4CAF50; }
        .boq-table td[contenteditable="true"] { background-color: #444; }
        .boq-table .quantity-cell { text-align: right; }
        .boq-table .unit-cell { text-align: center; }
        .boq-cell-active {
            background-color: #FFD700 !important;
            color: #000;
        }

        /* ADD THIS CSS to control button wrapping in prompts */
.modal-buttons {
    display: flex;
    flex-wrap: wrap; /* Allows buttons to wrap to the next line */
    justify-content: space-around;
    gap: 10px; /* Adds space between buttons */
    margin-top: 20px;
    overflow-x: auto; /* Adds a scrollbar if content still overflows */
    padding-bottom: 5px; /* Provides space for the scrollbar */
}

.modal-buttons button {
    width: auto;
    padding: 10px 15px;
    flex-shrink: 0; /* Prevents buttons from shrinking */
}

/* ADD THIS CSS for the BOQ layout */
.boq-table tfoot {
    position: sticky;
    bottom: 0;
    background-color: #4CAF50;
    color: white;
    z-index: 1;
}

.boq-table-container {
    position: relative; /* Needed for the sticky footer to work within this container */
}

#verticalRuler {
    color: #ccc;
    font-size: 10px;
    padding-top: 10px; /* Adjust as needed to avoid top controls */
    box-sizing: border-box;
    pointer-events: none; /* Allows clicking through the ruler background */
}

.ruler-marker {
    position: absolute;
    left: 0;
    width: 100%;
    height: 1px;
    background-color: #4CAF50;
    cursor: pointer;
    border-top: 1px solid white;
    pointer-events: all; /* Makes only the markers clickable/hoverable */
}

/* Adds the text label (e.g., "3.20m") to the left of the marker line */
.ruler-marker::before {
    content: attr(data-level);
    position: absolute;
    right: 45px; /* Position text to the left of the ruler */
    top: -7px;
    color: white;
    width: 40px;
    text-align: right;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 1px 3px;
    border-radius: 3px;
}

/* REPLACE ALL PREVIOUS RULER CSS WITH THIS BLOCK */
/* REPLACE ALL PREVIOUS RULER CSS WITH THIS REFINED BLOCK */
#precisionRulerContainer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 55px; /* Thinner container */
    background: rgba(34, 34, 34, 0.95);
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 20;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    padding: 0 15px; /* Less padding */
    box-sizing: border-box;
}

#rulerTrack {
    position: relative;
    width: 85%; /* Much wider track */
    height: 20px;
    background-color: #1a1a1a;
    border: 1px solid #555;
    border-radius: 2px;
    cursor: ew-resize;
    /* Ruler markings using gradients */
    background-image:
        linear-gradient(to right, #aaa 1px, transparent 1px),
        linear-gradient(to right, #888 1px, transparent 1px),
        linear-gradient(to right, #555 1px, transparent 1px);
    background-size: 10% 100%, 5% 100%, 1% 100%;
    background-position: 0 0, 0 50%, 0 75%;
    background-repeat: repeat-x, repeat-x, repeat-x;
}

#rulerThumb {
    position: absolute;
    top: -5px;
    left: 50%; /* Starts at '0' */
    width: 3px;
    height: 30px;
    background-color: #f44336;
    border: 1px solid white;
    transform: translateX(-50%);
    pointer-events: none;
    box-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
}

#ruler-labels {
    position: absolute;
    bottom: 100%; /* Position labels above the track */
    width: 100%;
    height: 20px;
    pointer-events: none;
    color: #ccc;
    font-size: 11px;
}

/* Perfect alignment for each label */
#ruler-labels span {
    position: absolute;
    transform: translateX(-50%); /* Horizontally center the label text */
}
#ruler-labels span:nth-child(1) { left: 0%; transform: translateX(0%); } /* Align start */
#ruler-labels span:nth-child(2) { left: 25%; }
#ruler-labels span:nth-child(3) { left: 37.5%; }
#ruler-labels span:nth-child(4) { left: 50%; font-weight: bold; font-size: 13px; } /* Center '0' */
#ruler-labels span:nth-child(5) { left: 62.5%; }
#ruler-labels span:nth-child(6) { left: 75%; }
#ruler-labels span:nth-child(7) { left: 100%; transform: translateX(-100%); } /* Align end */

#rulerValueBox {
    margin-left: 20px;
    display: flex;
    align-items: center;
}

#rulerValueInput {
    width: 110px;
    padding: 6px;
    background-color: #222;
    border: 1px solid #555;
    color: #FFD700;
    font-weight: bold;
    font-size: 15px;
    text-align: right;
    border-radius: 5px;
}

#rulerValueBox span { margin-left: 8px; color: #ccc; font-size: 14px; }

/* ADD THIS CSS FOR THE NEW LAYER MANAGER */
#layerList li {
    padding: 6px 4px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    align-items: center;
    font-size: 14px;
}
#layerList li:hover {
    background-color: rgba(255, 255, 255, 0.1);
}
#layerList li.active-layer {
    background-color: #4CAF50;
    font-weight: bold;
}
#layerList input[type="checkbox"] {
    margin-right: 10px;
    flex-shrink: 0;
}

     </style>
 </head>

 <body>
    <div id="splashScreen">
    <div id="splash-background"></div> <div id="splash-overlay"></div> <div id="splashContent">
        <h1 id="splashTitle">Q-Est</h1>
        <div class="progress-container">
            <div id="progressBar"></div>
        </div>
        <p id="splashMessage">Finalizing Workspace...</p>
    </div>
</div>

<div class="top-interface-container">
    <div id="ribbon-1" class="control-ribbon">
        <div id="projectControls" class="controls">
            <button id="saveProjectBtn" style="background-color: #673AB7;" title="Save Project"><i class="fas fa-save"></i></button>
            <button id="loadProjectBtn" style="background-color: #673AB7;" title="Load Project"><i class="fas fa-folder-open"></i></button>
        </div>
        <div id="drawingControls" class="controls">
            <label for="drawingSelect" title="Current Drawing"><i class="fas fa-clipboard"></i></label>
            <select id="drawingSelect"></select>
            <button id="importBtn" title="Import New Drawing"><i class="fas fa-file-import"></i></button>
            <button id="deleteDrawingBtn" style="background-color: #c9342d;" title="Delete Drawing"><i class="fas fa-trash-can"></i></button>
        </div>

        <div id="mainActions" class="controls">
             <button id="setScaleBtn" title="Set Scale"><i class="fas fa-ruler-horizontal"></i></button>
             <button id="dittoBtn" style="background-color: #9C27B0;" title="Ditto (Clone BOQ Item)"><i class="fas fa-clone"></i></button> 
             <button id="copyMoveBtn" style="background-color: #ff9800;" title="Copy & Move"><i class="fas fa-copy"></i></button>
             <button id="toggleCurveBtn" title="Toggle Curve Mode (C)" style="background-color: #90A4AE;"><i class="fas fa-wave-square"></i></button>
             <button id="undoBtn" title="Undo"><i class="fas fa-undo"></i></button>
             <button id="clearBtn" title="Clear Layer"><i class="fas fa-xmark"></i></button>
        </div>
        <div id="viewAndQuantify" class="controls">
            <button id="toggle3D" title="Toggle 3D View"><i class="fas fa-cube"></i></button>
            <button id="showBoqBtn" style="background-color: #00bcd4;" title="Show BOQ"><i class="fas fa-table"></i></button>
            <button id="toggleAggregateBtn" title="Aggregate quantities" style="background-color: #E67E22; width: auto; padding: 5px 8px;"><i class="fas fa-calculator"></i> Aggregate</button>
            <button id="toggleDeductBtn" title="Deduct quantities" style="background-color: #F39C12; width: auto; padding: 5px 8px;"><i class="fas fa-minus-circle"></i> Deduct</button>
        </div>
    </div>

    <div id="ribbon-2" class="control-ribbon">
        <div id="smmControls" class="controls">
            <label for="smmDbSelect"><i class="fas fa-database"></i></label>
            <select id="smmDbSelect" style="min-width: 150px;"></select>
            <button id="loadSmmDbBtn" style="background-color: #ff9800;">Load DB</button>
            <span id="smmDbStatus" style="font-size: 12px; margin-left: 10px; color: #f44336;">Disconnected</span>
        </div>
        <div id="toolSelector" class="controls">
            <label for="shapeType" title="Drawing Tool"><i class="fas fa-pencil-alt"></i></label>
            <select id="shapeType">
                <option value="polygon">Polygon</option>
                <option value="variablePolygon">Variable Polygon</option>
                <option value="polyline">Polyline</option>
                <option value="shell">Shell</option>
                <option value="circle">Circle</option>
                <option value="freehand">Freehand</option>
                <option value="count">Count</option>
                <option value="eraser">Eraser</option>
            </select>
        </div>
        <div id="rebarControls" class="controls">
            <label>Mode:</label>
            <select id="rebarDrawModeSelect">
                <option value="planar">Planar Bars</option>
                <option value="vertical">Vertical Bars</option>
                <option value="stirrup">Stirrups</option>
            </select>
            <label for="rebarDiaSelect">Bar Diameter:</label>
            <select id="rebarDiaSelect"></select>
            <button id="finishRebarBtn" style="background-color: #f44336;">Finish Rebar Design</button>
            <span id="rebarModeInstructions" style="font-size: 12px; color: #FFD700; margin-left: 10px;"></span>
        </div>
        <input type="file" id="loadProjectInput" accept=".json,.q3d">
        <input type="file" id="fileInput" accept="image/*,application/pdf">
    </div>
</div>
 
    <div id="info-panel-container">
    <div id="totalQuantitiesBox" class="info-box">
        <h3>Element Take-off</h3>
        <p>Total Length: 0.00 m</p>
        <p>Total Plan Area: 0.00 m²</p>
        <p>Total Wall Area: 0.00 m²</p>
        <p>Total Volume: 0.00 m³</p>
        <p>Total Count: 0</p>
        <p>Scale: 1 meter = 1.00 pixels</p>
    </div>

    <div id="rebarQuantitiesBox" class="info-box">
        <h3>Rebar Take-off</h3>
        <p>Total Rebar Length: 0.00 m</p>
        <p>Total Rebar Weight: 0.00 kg</p>
    </div>

    <div id="scratchpadBox" class="info-box">
    <h3>
    Scratchpad
    <button id="calculateScratchpadBtn" title="Calculate Total" style="float: right; background: #007bff; border: none; color: white; border-radius: 5px; width: auto; height: 20px; cursor: pointer; line-height: 20px; text-align: center; font-size: 11px; padding: 0 8px; margin-left: 5px;">
        <i class="fas fa-calculator"></i> Calc
    </button>
    <button id="clearScratchpadBtn" title="Clear Scratchpad" style="float: right; background: #c9342d; border: none; color: white; border-radius: 5px; width: auto; height: 20px; cursor: pointer; line-height: 20px; text-align: center; font-size: 11px; padding: 0 8px;">
        <i class="fas fa-trash"></i> Clear
    </button>
</h3>
    <div id="scratchpadContent" style="max-height: 150px; overflow-y: auto;">
        <table class="boq-table" style="font-size: 12px;">
            <thead>
                <tr>
                    <th style="width: 70%;">Description</th>
                    <th style="width: 30%;">Value</th>
                </tr>
            </thead>
            <tbody id="scratchpadTableBody">
                </tbody>
        </table>
    </div>
</div>

    <!-- ADD THIS SNIPPET -->
<div id="layerManagerBox" class="info-box">
    <h3>
        Layers
        <button id="addNewLayerBtn" title="Add New Layer" style="float: right; background: #007bff; border: none; color: white; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; line-height: 20px; text-align: center;">
            <i class="fas fa-plus"></i>
        </button>
    </h3>
    <ul id="layerList" style="list-style: none; padding: 0; margin: 0; max-height: 200px; overflow-y: auto;">
        <!-- Layers will be dynamically added here -->
    </ul>
</div>

    


    <div id="elementInfoBox" class="info-box">
        <h3>Element Details</h3>
        <div id="elementInfoContent">
            <p>Hover over an element in 3D view to see its details here.</p>
        </div>
    </div>

    <div id="aggregatorBox" class="info-box" style="display: none; border-color: #E67E22;">
        <h3><i class="fas fa-calculator"></i> Quantity Aggregator</h3>
        <p>Unit: <strong id="aggregatorUnit" style="color: #FFD700;">N/A</strong></p>
        <p>Current Sum: <strong id="aggregatorSum" style="color: #66BB6A;">0.00</strong></p>
        <div class="modal-buttons" style="justify-content: space-around; margin-top: 15px;">
            <button id="applyAggregateBtn" style="background-color: #4CAF50;">Apply to BOQ</button>
            <button id="cancelAggregateBtn" style="background-color: #f44336;">Cancel</button>
        </div>
    </div>

    <div id="deductorBox" class="info-box" style="display: none; border-color: #F39C12;">
        <h3><i class="fas fa-minus-circle"></i> Quantity Deductor</h3>
        <p>Primary: <strong id="deductorPrimary" style="color: #66BB6A;">0.00</strong> <strong id="deductorUnit" style="color: #FFD700;">N/A</strong></p>
        <p>Deductions: <strong id="deductorSum" style="color: #f44336;">0.00</strong></p>
        <div class="modal-buttons" style="justify-content: space-around; margin-top: 15px;">
            <button id="applyDeductBtn" style="background-color: #4CAF50;">Apply</button>
            <button id="cancelDeductBtn" style="background-color: #f44336;">Cancel</button>
        </div>
    </div>
</div>

     <div id="elementInfoBox" class="info-box">
         <h3>Element Details</h3>
         <div id="elementInfoContent">
             <p>Hover over an element in 3D view to see its details here.</p>
         </div>
     </div>

    <div id="precisionRulerContainer">
    <div id="rulerTrack">
        <div id="ruler-labels">
            <span>-1000m</span>
            <span>-500m</span>
            <span>-250m</span>
            <span>0m</span>
            <span>+250m</span>
            <span>+500m</span>
            <span>+1000m</span>
        </div>
        <div id="rulerThumb"></div>
    </div>
    <div id="rulerValueBox">
        <input type="number" id="rulerValueInput" step="1000" value="200">
        <span>mm</span>
    </div>
</div>

    <div id="verticalRuler" style="position: absolute; right: 0; top: 0; width: 40px; height: 100%; background: rgba(10,10,10,0.5); z-index: 5; border-left: 1px solid #555; display: none;">
    <!-- Markers will be added here by the new JavaScript functions -->
    </div>

    
 
     <canvas id="canvas"></canvas>
     <div id="threeDContainer"></div>
     <div id="tooltip"></div>
     <div id="angleIndicator"></div>


    <div id="boqModal" class="boq-modal">
    <div class="boq-content">
        <h3>Bill of Quantities (BOQ)</h3>
        <div class="boq-table-container">
                <table class="boq-table">
                <thead>
                    <tr>
                        <th style="width:40%;">Description</th>
                        <th style="width:15%;">Quantity</th>
                        <th style="width:10%;">Unit</th>
                        <th style="width:15%;">Rate</th>
                        <th style="width:15%;">Amount</th>
                        <th style="width:5%;"></th> </tr>
                </thead>
                <tbody id="boqTableBody">
                    </tbody>
                <tfoot id="boqTableFooter">
                    <tr>
                        <td colspan="4" style="text-align: right; font-weight: bold;">TOTAL AMOUNT</td>
                        <td id="boqTotalAmount" style="font-weight: bold; text-align: right;">0.00</td>
                    </tr>
                </tfoot>
            </table>
        </div>
        <div class="modal-buttons">
            <button id="addBoqRowBtn" style="background-color:#007bff">Add Row</button>
            <button id="exportBoqBtn" style="background-color:#1e8e3e">Export to Excel</button>
            <button id="closeBoqBtn" style="background-color:#777">Close</button>
        </div>
    </div>
</div>

<div id="profileDesignerModal" class="modal-container" style="display: none; z-index: 1002;">
    <div class="modal-content" style="max-width: 900px; width: 90%;">
        <h3>Design Shell Cross-Section</h3>
        <p style="font-size: 13px; color: #ccc; margin-bottom: 15px;">
            Use the tools to draw the profile shape. The <strong>red crosshair</strong> with scales represents the origin (0,0); the horizontal line is the ground level.
        </p>
        <div style="display: flex; gap: 15px;">
            <div style="flex-grow: 1; position: relative; width: 65%; aspect-ratio: 1.5 / 1; background: #2a2a2a; border-radius: 6px; border: 1px solid #555; overflow: hidden;">
                <canvas id="profileCanvas"></canvas>
                <div id="profileTooltip" style="position: absolute; background: rgba(0,0,0,0.7); color: white; padding: 5px; border-radius: 4px; font-size: 12px; pointer-events: none; display: none;"></div>
            </div>
            <div id="profileControls" style="width: 35%; display: flex; flex-direction: column; gap: 15px;">
                <div style="background-color: #383838; padding: 10px; border-radius: 6px;">
                    <h4 style="color: #00bcd4; margin: 0 0 10px 0;">Profile Tools</h4>
                    <div class="modal-buttons" style="margin-top:0; justify-content: space-around;">
                        <button id="profileDrawPolyBtn" style="background-color: #007bff;"><i class="fas fa-draw-polygon"></i> Draw</button>
                        <button id="profileCurveBtn" title="Toggle Curve Mode"><i class="fas fa-wave-square"></i> Curve</button>
                        <button id="profileUndoBtn" title="Undo Last Point"><i class="fas fa-undo"></i> Undo</button>
                        <button id="profileClearBtn" title="Clear Profile"><i class="fas fa-trash"></i> Clear</button>
                        </div>
                </div>
                <div id="profileRebarControls" style="background-color: #383838; padding: 10px; border-radius: 6px;">
                    <h4 style="color: #4CAF50; margin-top: 0; margin-bottom: 10px;">Rebar Design</h4>
                    <label for="profileRebarDia" style="font-size: 13px;">Diameter:</label>
                    <select id="profileRebarDia" style="width: 100%; padding: 4px; font-size: 12px; margin-bottom: 10px;"></select>
                    
                    <div class="modal-buttons" style="margin-top:0; justify-content: space-between; gap: 5px;">
                         <button id="addLongitudinalBtn" title="Add bars showing cross-section"><i class="fas fa-circle-dot"></i> Longitudinal</button>
                         <button id="addStirrupBtn" title="Draw bars showing true length"><i class="fas fa-vector-square"></i> Stirrup/Tie</button>
                    </div>
                    <ul id="profileRebarList" style="list-style: none; padding: 0; margin-top: 10px; font-size: 12px; max-height: 120px; overflow-y: auto;">
                        </ul>
                </div>
            </div>
        </div>
        <div class="modal-buttons">
            <button id="profileOkBtn" style="background-color:#4CAF50">Accept Profile</button>
            <button id="profileCancelBtn" style="background-color:#f44336">Cancel</button>
        </div>
    </div>
</div>

     <script>
         // --- Globals ---
         const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
         // *** MODIFICATION START: Drawing Management Data Structure ***
         let drawings = {};
         let activeDrawingName = null;
         // *** MODIFICATION END ***
         let scratchpadData = []; // <--- ADD THIS LINE
         let mouseDown = false, lastX, lastY;
         let currentShape = {};
         let scaleMode = false, scalePoints = [];
         const LOOP_THRESHOLD = 10, STEEL_DENSITY_KG_PER_M3 = 7850, ERASER_RADIUS = 15;
         let isDrawingFreehand = false;
         let isPanning = false, isErasing = false;
         let copyMoveMode = { active: false, shape: null, grabPoint: null };
        // --- MODIFICATION START: Curve Mode Globals ---
         let isCurveMode = false;
         let tempControlPoint = null; // To hold the control point while drawing a curve segment
         // --- MODIFICATION END ---

         // --- MODIFY THESE GLOBALS ---
let isDeducting = false;
// Add `stage` to track if we're drawing the primary or a deduction shape.
// Add `tempShapes` to store the temporary drawings for visualization.
let deductor = { 
    primary: null, 
    deductionsSum: 0, 
    stage: 'primary', 
    tempShapes: [] 
};
// --- END OF MODIFICATION ---
 
         // --- Rebar Mode Globals ---
         let rebarMode = { active: false, parentShape: null, drawingMode: 'planar' };
         let currentRebarLine = {}, currentStirrupShape = {};
         const REBAR_DIAMETERS = [8, 10, 12, 16, 20, 25, 32];
 
         // --- 3D Scene Variables ---
         let scene, camera, renderer, controls, threeDContainer = document.getElementById('threeDContainer');
         let is3DMode = false, animationFrameId, raycaster, mouse = new THREE.Vector2();
         let tooltip = document.getElementById('tooltip');
         let angleIndicator = document.getElementById('angleIndicator');
         let baseElevationLine, topElevationLine; 
 
         const elementColorMap = { 'wall': '#FF6B6B', 'slab': '#4ECDC4', 'beam': '#45B7D1', 'footing': '#F7B801', 'column': '#9B5DE5', 'count': '#FFD700' };
         function getElementColor(name) {
             const lowerCaseName = name.toLowerCase();
             for (const key in elementColorMap) if (lowerCaseName.includes(key)) return elementColorMap[key];
             return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
         }
         
         // --- PDF Handling ---
         async function handlePdfFile(file, drawingName) {
             const reader = new FileReader();
             reader.onload = async (event) => {
                 pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;
                 const loadingTask = pdfjsLib.getDocument({ data: event.target.result });
                 try {
                     const pdf = await loadingTask.promise;
                     const numPages = pdf.numPages;
                     let pageNumStr = numPages > 1 ? await customPrompt('Select PDF Page', `This PDF has ${numPages} pages. Enter a page number to import (1-${numPages}):`, '1') : '1';
                     const pageNum = parseInt(pageNumStr, 10);
                     if (!pageNumStr || isNaN(pageNum) || pageNum < 1 || pageNum > numPages) { customAlert('Invalid page number. Import cancelled.'); return; }
                     const page = await pdf.getPage(pageNum);
                     const renderScale = 2.0;
                     const viewport = page.getViewport({ scale: renderScale });
                     const tempCanvas = document.createElement('canvas');
                     const tempCtx = tempCanvas.getContext('2d');
                     tempCanvas.width = viewport.width;
                     tempCanvas.height = viewport.height;
                     const renderContext = { canvasContext: tempCtx, viewport: viewport };
                     await page.render(renderContext).promise;
                     // *** MODIFICATION: Add as new drawing ***
                     addNewDrawing(drawingName, tempCanvas.toDataURL('image/png'));
                 } catch (error) { console.error('Error processing PDF:', error); customAlert('Failed to load or render the PDF page. See console for details.'); }
             };
             reader.readAsArrayBuffer(file);
         }
 
         // --- Utility & Modal Functions ---
         function customAlert(message) {
             return new Promise(resolve => {
                 const m = document.createElement('div');
                 m.className = 'modal-container';
                 const c = document.createElement('div');
                 c.className = 'modal-content';
                 c.innerHTML = `<h3>Notification</h3><p style="margin-bottom:15px;font-size:14px;">${message}</p><div class="modal-buttons"><button id="modalOk" style="background-color:#4CAF50">OK</button></div>`;
                 m.appendChild(c);
                 document.body.appendChild(m);
                 const cl = () => { document.body.removeChild(m); resolve(); };
                 c.querySelector('#modalOk').onclick = cl;
             });
         }
         function customPrompt(title, message, defaultValue = '', inputType = 'text') {
             return new Promise(resolve => {
                 const m = document.createElement('div');
                 m.className = 'modal-container';
                 const c = document.createElement('div');
                 c.className = 'modal-content';
                 let inputElement;
                 if (inputType === 'textarea') {
                     inputElement = `<textarea rows="4" style="width:100%;padding:8px;margin-bottom:15px;border-radius:6px;border:1px solid #555;background:#222;color:white;">${defaultValue}</textarea>`;
                 } else {
                     inputElement = `<input type="text" value="${defaultValue}" style="width:100%;padding:8px;margin-bottom:15px;border-radius:6px;border:1px solid #555;background:#222;color:white;">`;
                 }
                 c.innerHTML = `<h3>${title}</h3><p style="margin-bottom:15px;font-size:14px;">${message}</p>${inputElement}<div class="modal-buttons"><button id="modalOk" style="background-color:#4CAF50">OK</button><button id="modalCancel" style="background-color:#f44336">Cancel</button></div>`;
                 m.appendChild(c);
                 document.body.appendChild(m);
                 const i = c.querySelector(inputType === 'textarea' ? 'textarea' : 'input');
                 i.focus();
                 i.select();
                 const cl = v => { document.body.removeChild(m); resolve(v); };
                 c.querySelector('#modalOk').onclick = () => cl(i.value);
                 c.querySelector('#modalCancel').onclick = () => cl(null);
                 if (inputType !== 'textarea') { i.onkeydown = e => { if (e.key === 'Enter') cl(i.value); }; }
             });
         }

// ADD THIS ENTIRE NEW FUNCTION
/**
 * Shows a modal with a canvas for the user to draw a 2D cross-section profile.
 * @returns {Promise<Array<{x: number, y: number}>|null>} A promise that resolves with the array of profile points, or null if cancelled.
 */

// REPLACE THE ENTIRE showProfileDesigner FUNCTION WITH THIS

/**
 * Shows a modal for designing a 2D cross-section with freehand drawing and rebar placement.
 * @returns {Promise<{profile: Array<{x, y}>, rebar: Array<{x, y, dia}>}|null>} Resolves with profile and rebar data.
 */
// REPLACE THE ENTIRE showProfileDesigner FUNCTION WITH THIS

/**
 * Shows a modal for designing a 2D cross-section with multiple drawing and rebar modes.
 * @returns {Promise<{profile: object[], rebar: object[], stirrups: object[]}|null>}
 */
// REPLACE THE EN-TIRE showProfileDesigner FUNCTION WITH THIS
function showProfileDesigner() {
    return new Promise(resolve => {
        const modal = document.getElementById('profileDesignerModal');
        const canvas = document.getElementById('profileCanvas');
        const ctx = canvas.getContext('2d');
        const drawBtn = document.getElementById('profileDrawPolyBtn');
        const curveBtn = document.getElementById('profileCurveBtn');
        const undoBtn = document.getElementById('profileUndoBtn');
        const clearBtn = document.getElementById('profileClearBtn');
        const addLongitudinalBtn = document.getElementById('addLongitudinalBtn');
        const addStirrupBtn = document.getElementById('addStirrupBtn');
        const rebarDiaSelect = document.getElementById('profileRebarDia');
        const okBtn = document.getElementById('profileOkBtn');
        const cancelBtn = document.getElementById('profileCancelBtn');
        const tooltip = document.getElementById('profileTooltip');

        modal.style.display = 'flex';

        let profilePoints = [], rebarPoints = [], stirrups = [];
        let currentStirrupLine = { points: [] };
        let isClosed = false;
        let rebarDrawMode = null;
        let isProfileCurveMode = false;
        let tempProfileControlPoint = null;
        const METER_SCALE = 100, GRID_SPACING = 20;

        rebarDiaSelect.innerHTML = REBAR_DIAMETERS.map(d => `<option value="${d}">${d}mm</option>`).join('');

        const getMousePos = e => ({ x: e.clientX - canvas.getBoundingClientRect().left, y: e.clientY - canvas.getBoundingClientRect().top });
        const toMeters = p => ({ x: (p.x - canvas.width / 2) / METER_SCALE, y: -(p.y - canvas.height / 2) / METER_SCALE });
        const resizeCanvas = () => { if (canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; draw(); } };

        const drawGrid = () => {
            ctx.strokeStyle = '#444'; ctx.lineWidth = 0.5;
            ctx.font = '10px Arial'; ctx.fillStyle = '#999';

            for (let x = canvas.width / 2; x < canvas.width; x += GRID_SPACING) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
                if ((x - canvas.width / 2) % (GRID_SPACING * 5) === 0 && x !== canvas.width / 2) {
                    const meterVal = ((x - canvas.width / 2) / METER_SCALE).toFixed(1);
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText(`${meterVal}m`, x, canvas.height / 2 - 5);
                }
            }
            for (let x = canvas.width / 2 - GRID_SPACING; x > 0; x -= GRID_SPACING) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
                if ((canvas.width / 2 - x) % (GRID_SPACING * 5) === 0) {
                    const meterVal = ((x - canvas.width / 2) / METER_SCALE).toFixed(1);
                    ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                    ctx.fillText(`${meterVal}m`, x, canvas.height / 2 - 5);
                }
            }
            for (let y = canvas.height / 2; y < canvas.height; y += GRID_SPACING) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
                if ((y - canvas.height / 2) % (GRID_SPACING * 5) === 0 && y !== canvas.height / 2) {
                    const meterVal = (-(y - canvas.height / 2) / METER_SCALE).toFixed(1);
                    ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                    ctx.fillText(`${meterVal}m`, canvas.width / 2 + 5, y);
                }
            }
            for (let y = canvas.height / 2 - GRID_SPACING; y > 0; y -= GRID_SPACING) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
                if ((canvas.height / 2 - y) % (GRID_SPACING * 5) === 0) {
                    const meterVal = (-(y - canvas.height / 2) / METER_SCALE).toFixed(1);
                    ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                    ctx.fillText(`${meterVal}m`, canvas.width / 2 + 5, y);
                }
            }
        };

        const drawOrigin = () => { ctx.strokeStyle = '#f44336'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, canvas.height / 2); ctx.lineTo(canvas.width, canvas.height / 2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke(); };
        
        function drawShape() {
            if (profilePoints.length === 0) return;
            ctx.strokeStyle = '#FFD700'; ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(profilePoints[0].x, profilePoints[0].y);
            for (let i = 1; i < profilePoints.length; i++) {
                const p = profilePoints[i];
                if (p.isCurve) { ctx.quadraticCurveTo(p.cpx, p.cpy, p.x, p.y); } 
                else { ctx.lineTo(p.x, p.y); }
            }
            if (isClosed) { ctx.closePath(); ctx.fill(); }
            ctx.stroke();
        }

        function drawRebar() { 
            rebarPoints.forEach(bar => {
                const radius = (bar.dia / 1000 * METER_SCALE) / 2;
                const canvasX = (bar.x * METER_SCALE) + (canvas.width / 2);
                const canvasY = (-bar.y * METER_SCALE) + (canvas.height / 2);
                ctx.beginPath(); ctx.arc(canvasX, canvasY, Math.max(2, radius), 0, 2 * Math.PI);
                ctx.fillStyle = '#A9A9A9'; ctx.fill(); ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1; ctx.stroke();
            });
            stirrups.forEach(stirrup => {
                const stirrupDiaPx = (stirrup.dia / 1000 * METER_SCALE) / 2;
                ctx.beginPath();
                ctx.moveTo(stirrup.points[0].x, stirrup.points[0].y);
                for (let i = 1; i < stirrup.points.length; i++) ctx.lineTo(stirrup.points[i].x, stirrup.points[i].y);
                ctx.strokeStyle = '#4682B4'; ctx.lineWidth = Math.max(1, stirrupDiaPx); ctx.stroke();
            });
            if (rebarDrawMode === 'stirrup' && currentStirrupLine.points.length > 0) {
                 ctx.beginPath();
                 ctx.moveTo(currentStirrupLine.points[0].x, currentStirrupLine.points[0].y);
                 for (let i = 1; i < currentStirrupLine.points.length; i++) ctx.lineTo(currentStirrupLine.points[i].x, currentStirrupLine.points[i].y);
                 ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 2; ctx.stroke();
            }
         }

        const drawWithMousePos = e => draw(getMousePos(e));

        const draw = (mousePos = null) => {
            ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid(); drawOrigin(); drawShape(); drawRebar();
            
            // --- FIX START: Only draw the rubber-band line if the shape is NOT closed ---
            if (mousePos && profilePoints.length > 0 && rebarDrawMode === null && !isClosed) {
                ctx.setLineDash([5, 5]); ctx.lineWidth = 1.5;
                const lastPoint = profilePoints[profilePoints.length - 1];
                if (isProfileCurveMode && tempProfileControlPoint) {
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, lastPoint.y);
                    ctx.quadraticCurveTo(tempProfileControlPoint.x, tempProfileControlPoint.y, mousePos.x, mousePos.y);
                    ctx.strokeStyle = '#26C6DA';
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, lastPoint.y);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.strokeStyle = 'red';
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }
            // --- FIX END ---

            if (mousePos) {
                 const realPos = toMeters(mousePos);
                 tooltip.style.display = 'block';
                 tooltip.style.left = `${mousePos.x + 15}px`;
                 tooltip.style.top = `${mousePos.y + 15}px`;
                 tooltip.textContent = `X: ${realPos.x.toFixed(3)}m, Y: ${realPos.y.toFixed(3)}m`;
            } else {
                tooltip.style.display = 'none';
            }
        };

        function toggleProfileCurveMode(setActive = !isProfileCurveMode) {
            isProfileCurveMode = setActive;
            curveBtn.style.backgroundColor = isProfileCurveMode ? '#26C6DA' : '#444';
            tempProfileControlPoint = null;
            if(isProfileCurveMode) customAlert('Curve mode ON. First click sets the control point, then click the end point.');
        }

        function setRebarDrawMode(mode) { 
            rebarDrawMode = (rebarDrawMode === mode) ? null : mode;
            canvas.style.cursor = rebarDrawMode ? 'copy' : 'crosshair';
            updateRebarButtonStyles();
         }
        const updateRebarButtonStyles = () => { 
            addLongitudinalBtn.style.backgroundColor = rebarDrawMode === 'longitudinal' ? '#4CAF50' : '#444';
            addStirrupBtn.style.backgroundColor = rebarDrawMode === 'stirrup' ? '#4CAF50' : '#444';
        };
        
        function handleCanvasClick(e) {
            const pos = getMousePos(e);
            if (rebarDrawMode === 'longitudinal') {
                const realPos = toMeters(pos);
                rebarPoints.push({ x: realPos.x, y: realPos.y, dia: parseFloat(rebarDiaSelect.value) });
            } else if (rebarDrawMode === 'stirrup') {
                currentStirrupLine.points.push(pos);
            } else {
                if (isProfileCurveMode) {
                    if (profilePoints.length === 0) { profilePoints.push({ x: pos.x, y: pos.y, isCurve: false }); }
                    else if (!tempProfileControlPoint) { tempProfileControlPoint = { x: pos.x, y: pos.y }; customAlert('Control point set. Click the curve\'s end point.'); }
                    else { profilePoints.push({ x: pos.x, y: pos.y, isCurve: true, cpx: tempProfileControlPoint.x, cpy: tempProfileControlPoint.y }); tempProfileControlPoint = null; toggleProfileCurveMode(false); }
                } else {
                    profilePoints.push({ x: pos.x, y: pos.y, isCurve: false });
                    if (profilePoints.length > 2 && Math.hypot(pos.x - profilePoints[0].x, pos.y - profilePoints[0].y) < 10) {
                        profilePoints.pop(); isClosed = true;
                    }
                }
            }
            draw(pos);
        }

        async function finalizeStirrup() { 
            if (currentStirrupLine.points.length < 2) return;
            const spacing = await customPrompt("Stirrup Spacing", "Enter spacing for this stirrup/tie (mm):", "150");
            if (spacing === null || isNaN(parseFloat(spacing))) {
                currentStirrupLine = { points: [] }; draw(); return;
            }
            stirrups.push({ 
                points: currentStirrupLine.points,
                dia: parseFloat(rebarDiaSelect.value),
                spacing: parseFloat(spacing)
            });
            currentStirrupLine = { points: [] };
            draw();
         }

        function handleKeyDown(e) { 
            if (e.key === 'Enter') { 
                if (rebarDrawMode === 'stirrup') {
                     finalizeStirrup(); 
                } else if (profilePoints.length > 2) {
                     isClosed = true; 
                }
                draw(); 
            } 
        }

         // --- FIX START: This function is now corrected ---
        const closeModal = (value) => { 
            // Correctly remove the event listeners that were actually added to this modal
            canvas.removeEventListener('mousemove', drawWithMousePos);
            canvas.removeEventListener('click', handleCanvasClick);
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('resize', resizeCanvas);
            
            // Nullify onclick handlers to prevent potential memory leaks
            okBtn.onclick = null;
            cancelBtn.onclick = null;
            drawBtn.onclick = null;
            curveBtn.onclick = null;
            undoBtn.onclick = null;
            clearBtn.onclick = null;
            addLongitudinalBtn.onclick = null;
            addStirrupBtn.onclick = null;

            modal.style.display = 'none';
            resolve(value);
        };
        // --- FIX END ---
        
        okBtn.onclick = () => {
             const finalProfilePoints = profilePoints.map(p => ({ ...toMeters(p), isCurve: p.isCurve, cpx: p.cpx ? toMeters({x:p.cpx, y:p.cpy}).x : undefined, cpy: p.cpx ? toMeters({x:p.cpx, y:p.cpy}).y : undefined }));
             const finalStirrups = stirrups.map(s => ({ ...s, points: s.points.map(p => toMeters(p)) }));
             closeModal({ profile: finalProfilePoints, rebar: rebarPoints, stirrups: finalStirrups });
        };
        cancelBtn.onclick = () => closeModal(null);
        drawBtn.onclick = () => setRebarDrawMode(null);
        curveBtn.onclick = () => toggleProfileCurveMode();
        undoBtn.onclick = () => { profilePoints.pop(); tempProfileControlPoint = null; isClosed = false; draw(); };
        clearBtn.onclick = () => { profilePoints = []; tempProfileControlPoint = null; isClosed = false; draw(); };
        addLongitudinalBtn.onclick = () => setRebarDrawMode('longitudinal');
        addStirrupBtn.onclick = () => setRebarDrawMode('stirrup');

        canvas.addEventListener('mousemove', drawWithMousePos);
        canvas.addEventListener('click', handleCanvasClick);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('resize', resizeCanvas);
        
        setRebarDrawMode(null);
        resizeCanvas();
    });
}

function showScratchpadSelectionModal(items) {
    return new Promise(resolve => {
        const modal = document.createElement('div');
        modal.className = 'modal-container';

        // Group items by unit to display them in sections
        const groupedItems = items.reduce((acc, item) => {
            const unit = item.unit || 'N/A';
            (acc[unit] = acc[unit] || []).push(item);
            return acc;
        }, {});

        let listHTML = '';
        let itemIndex = 0;
        for (const unit in groupedItems) {
            listHTML += `<h4 style="color: #FFD700; margin-top: 10px; margin-bottom: 5px; border-bottom: 1px solid #555;">Unit: ${unit}</h4>`;
            groupedItems[unit].forEach(item => {
                listHTML += `
                    <div style="display: flex; align-items: center; padding: 4px 0;">
                        <input type="checkbox" id="item-${itemIndex}" data-index="${itemIndex}" data-unit="${item.unit || 'N/A'}" style="margin-right: 10px;">
                        <label for="item-${itemIndex}" style="flex-grow: 1;">${item.description}</label>
                        <span style="font-weight: bold;">${item.value.toFixed(2)}</span>
                    </div>`;
                itemIndex++;
            });
        }

        modal.innerHTML = `
            <div class="modal-content" style="max-width: 500px;">
                <h3>Select Items to Calculate</h3>
                <p>Mixed units detected. Please select items of the same unit to calculate.</p>
                <div id="scratchpad-selection-list" style="max-height: 300px; overflow-y: auto; border: 1px solid #555; padding: 10px; border-radius: 6px; margin-top: 15px;">
                    ${listHTML}
                </div>
                <div class="modal-buttons">
                    <button id="modalOk" style="background-color:#4CAF50">Calculate Selected</button>
                    <button id="modalCancel" style="background-color:#f44336">Cancel</button>
                </div>
            </div>`;

        document.body.appendChild(modal);

        const listContainer = modal.querySelector('#scratchpad-selection-list');

        // Logic to disable checkboxes of different units once a selection is made
        listContainer.addEventListener('change', (e) => {
            if (e.target.type !== 'checkbox') return;

            const allCheckboxes = listContainer.querySelectorAll('input[type="checkbox"]');
            const selectedCheckboxes = Array.from(allCheckboxes).filter(cb => cb.checked);

            if (selectedCheckboxes.length > 0) {
                const selectedUnit = selectedCheckboxes[0].dataset.unit;
                allCheckboxes.forEach(cb => {
                    cb.disabled = (cb.dataset.unit !== selectedUnit);
                });
            } else {
                allCheckboxes.forEach(cb => { cb.disabled = false; });
            }
        });
        
        const closeModal = (value) => {
            document.body.removeChild(modal);
            resolve(value);
        };

        modal.querySelector('#modalOk').onclick = () => {
            const selectedCheckboxes = Array.from(listContainer.querySelectorAll('input:checked'));
            if (selectedCheckboxes.length === 0) {
                customAlert("Please select at least one item.");
                return;
            }

            const selectedUnit = selectedCheckboxes[0].dataset.unit;
            const total = selectedCheckboxes.reduce((sum, cb) => {
                const index = parseInt(cb.dataset.index, 10);
                const item = items[index];
                return item.description.includes('-') ? sum - item.value : sum + item.value;
            }, 0);

            closeModal({ total, unit: selectedUnit });
        };
        modal.querySelector('#modalCancel').onclick = () => closeModal(null);
    });
}

// Estimator8.0.html

// REPLACE this function
async function addDescriptionToBoq(description) {
    const boqTableBody = document.getElementById('boqTableBody');
    let targetCell = null;
    let targetRow = null;

    const rows = boqTableBody.querySelectorAll('tr');
    for (const row of rows) {
        const descCell = row.children[0];
        if (!descCell.textContent || descCell.textContent.trim() === '' || descCell.textContent === 'Click to edit description...') {
            targetCell = descCell;
            targetRow = row;
            break;
        }
    }

    if (!targetCell) {
        addBoqRow();
        targetRow = boqTableBody.lastChild;
        targetCell = targetRow.children[0];
    }

    targetCell.textContent = description;
    document.getElementById('boqModal').style.display = 'flex';

    // MODIFIED: Launch the rate builder right after setting the description
    const rate = await showRateBuilder(description);
    if (rate !== null) {
        const rateCell = targetRow.children[3];
        rateCell.textContent = rate.toFixed(2);
        updateBoqRowAmount(targetRow); // Calculate amount
    }
}



// *** REBUILT DESCRIPTION BUILDER ***
function showDescriptionBuilder() {
    const statusText = document.getElementById('smmDbStatus').textContent;
    if (!statusText.startsWith('Connected')) {
        customAlert("Please load a database first.");
        return Promise.resolve(null);
    }
    
    return new Promise(resolve => {
        // --- 1. Create Modal UI ---
        const modal = document.createElement('div');
        modal.className = 'modal-container';
        // UI now includes a dropdown for tables and a container for the data grid
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 900px; width: 90%;">
                <h3>Description Builder</h3>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <label for="tableSelect" style="margin-right: 10px;">Select Table:</label>
                    <select id="tableSelect" style="flex-grow: 1;"></select>
                </div>
                <div id="table-display" style="height: 300px; overflow: auto; border: 1px solid #555; background: #2a2a2a; border-radius: 6px; margin-bottom: 10px;">
                    </div>
                <textarea id="built-description" rows="4" placeholder="Click on any cell in the table above to append its content here..."></textarea>
                <div class="modal-buttons">
                    <button id="builderOkBtn" style="background-color:#4CAF50">OK</button>
                    <button id="builderCancelBtn" style="background-color:#f44336">Cancel</button>
                </div>
            </div>`;
        document.body.appendChild(modal);

        const tableSelect = modal.querySelector('#tableSelect');
        const tableDisplay = modal.querySelector('#table-display');
        const descriptionArea = modal.querySelector('#built-description');

        // --- 2. Core Logic ---

        // Fetches table list and populates the dropdown
        const populateTableSelect = async () => {
            try {
                const response = await fetch('http://localhost:3000/api/list-tables');
                const tableNames = await response.json();
                tableSelect.innerHTML = '<option value="">-- Choose a table --</option>';
                tableNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    tableSelect.appendChild(option);
                });
            } catch (error) {
                console.error("Failed to fetch tables:", error);
                tableDisplay.innerHTML = `<p style="color: #f44336;">Error: Could not fetch table list.</p>`;
            }
        };

        // Fetches content of the selected table and renders it
        const fetchAndDisplayTableContent = async (tableName) => {
            if (!tableName) {
                tableDisplay.innerHTML = '<p>Please select a table from the dropdown.</p>';
                return;
            }
            tableDisplay.innerHTML = '<p>Loading table data...</p>';
            try {
                const response = await fetch(`http://localhost:3000/api/table-content/${tableName}`);
                const rows = await response.json();
                
                if (rows.length === 0) {
                    tableDisplay.innerHTML = '<p>This table is empty.</p>';
                    return;
                }

                // Dynamically create an HTML table from the JSON data
                const table = document.createElement('table');
                table.className = 'boq-table'; // Reuse your BOQ table style
                const thead = table.createTHead();
                const tbody = table.createTBody();
                const headerRow = thead.insertRow();
                
                // Create headers from the keys of the first object
                Object.keys(rows[0]).forEach(key => {
                    const th = document.createElement('th');
                    th.textContent = key;
                    headerRow.appendChild(th);
                });

                // Create body rows
                rows.forEach(rowData => {
                    const row = tbody.insertRow();
                    Object.values(rowData).forEach(value => {
                        const cell = row.insertCell();
                        cell.textContent = value;
                        // This makes cells clickable
                        cell.style.cursor = 'pointer';
                        cell.title = 'Click to add to description';
                    });
                });
                
                tableDisplay.innerHTML = '';
                tableDisplay.appendChild(table);

            } catch (error) {
                console.error(`Failed to fetch content for ${tableName}:`, error);
                tableDisplay.innerHTML = `<p style="color: #f44336;">Error: Could not load table content.</p>`;
            }
        };

        const closeModal = (value) => {
            document.body.removeChild(modal);
            resolve(value);
        };
        
        // --- 3. Event Listeners ---
        tableSelect.addEventListener('change', () => fetchAndDisplayTableContent(tableSelect.value));
        
        // *** REPLACE THE OLD CLICK LISTENER WITH THIS NEW ASYNC VERSION ***
    tableDisplay.addEventListener('click', async (e) => {
        if (e.target && e.target.nodeName === 'TD') {
            const cellText = e.target.textContent.trim();
            if (!cellText) return; // Do nothing if the cell is empty

            let textToAdd = '';

            // Check if the cell content contains a semicolon
            if (cellText.includes(';')) {
                // If it does, split the content into parts
                const parts = cellText.split(';').map(part => part.trim());
                
                // Create choice objects for the prompt
                const choices = parts.map((part, index) => ({
                    id: `part_${index}`,
                    text: part,
                    color: '#007bff' // Standard blue color for choices
                }));
                // Add a cancel button
                choices.push({id: 'cancel', text: 'Cancel', color: '#777'});

                // Use the existing choicePrompt to ask the user which part they want
                const chosenId = await choicePrompt("Select Part", "This item contains multiple parts. Please choose one to add:", choices);

                // If the user made a valid choice (not cancel)
                if (chosenId && chosenId !== 'cancel') {
                    const chosenIndex = parseInt(chosenId.split('_')[1], 10);
                    textToAdd = parts[chosenIndex];
                } else {
                    return; // User cancelled, so we stop here.
                }
            } else {
                // If there's no semicolon, use the entire cell content as before
                textToAdd = cellText;
            }

            // Append the chosen text to the description area
            if (textToAdd) {
                const currentText = descriptionArea.value;
                descriptionArea.value += (currentText ? ' ' : '') + textToAdd;
            }
        }
    });

        modal.querySelector('#builderOkBtn').onclick = () => closeModal(descriptionArea.value);
        modal.querySelector('#builderCancelBtn').onclick = () => closeModal(null);

        // --- 4. Initial Call ---
        populateTableSelect();
        fetchAndDisplayTableContent(null);
    });
}

// ADD THIS NEW FUNCTION AFTER showDescriptionBuilder
function showRateBuilder(descriptionForContext) {
    const statusText = document.getElementById('smmDbStatus').textContent;
    if (!statusText.startsWith('Connected')) {
        customAlert("Please load a database first.");
        return Promise.resolve(null);
    }
    
    return new Promise(resolve => {
        // --- 1. Create Modal UI ---
        const modal = document.createElement('div');
        modal.className = 'modal-container';
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 900px; width: 90%;">
                <h3>Rate Selector</h3>
                <p style="margin-bottom:10px; font-size:13px; color:#ccc;">For Item: <strong>${descriptionForContext.substring(0, 100)}...</strong></p>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <label for="tableSelect" style="margin-right: 10px;">Select Table:</label>
                    <select id="tableSelect" style="flex-grow: 1;"></select>
                </div>
                <div id="table-display" style="height: 300px; overflow: auto; border: 1px solid #555; background: #2a2a2a; border-radius: 6px; margin-bottom: 10px;">
                    </div>
                <input type="text" id="selected-rate" placeholder="Click on a numeric cell in the table above..." readonly style="background-color: #444; text-align: right;">
                <div class="modal-buttons">
                    <button id="builderOkBtn" style="background-color:#4CAF50">OK</button>
                    <button id="builderCancelBtn" style="background-color:#f44336">Cancel</button>
                </div>
            </div>`;
        document.body.appendChild(modal);

        const tableSelect = modal.querySelector('#tableSelect');
        const tableDisplay = modal.querySelector('#table-display');
        const rateInput = modal.querySelector('#selected-rate');

        // --- 2. Core Logic ---
        const populateTableSelect = async () => {
            try {
                const response = await fetch('http://localhost:3000/api/list-tables');
                const tableNames = await response.json();
                tableSelect.innerHTML = '<option value="">-- Choose a table --</option>';
                tableNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    tableSelect.appendChild(option);
                });
            } catch (error) {
                console.error("Failed to fetch tables:", error);
                tableDisplay.innerHTML = `<p style="color: #f44336;">Error: Could not fetch table list.</p>`;
            }
        };

        const fetchAndDisplayTableContent = async (tableName) => {
            if (!tableName) {
                tableDisplay.innerHTML = '<p>Please select a table from the dropdown.</p>';
                return;
            }
            tableDisplay.innerHTML = '<p>Loading table data...</p>';
            try {
                const response = await fetch(`http://localhost:3000/api/table-content/${tableName}`);
                const rows = await response.json();
                
                if (rows.length === 0) {
                    tableDisplay.innerHTML = '<p>This table is empty.</p>';
                    return;
                }

                const table = document.createElement('table');
                table.className = 'boq-table';
                const thead = table.createTHead();
                const tbody = table.createTBody();
                const headerRow = thead.insertRow();
                
                Object.keys(rows[0]).forEach(key => {
                    const th = document.createElement('th');
                    th.textContent = key;
                    headerRow.appendChild(th);
                });

                rows.forEach(rowData => {
                    const row = tbody.insertRow();
                    Object.values(rowData).forEach(value => {
                        const cell = row.insertCell();
                        cell.textContent = value;
                        cell.style.cursor = 'pointer';
                        cell.title = 'Click to select this rate';
                    });
                });
                
                tableDisplay.innerHTML = '';
                tableDisplay.appendChild(table);

            } catch (error) {
                console.error(`Failed to fetch content for ${tableName}:`, error);
                tableDisplay.innerHTML = `<p style="color: #f44336;">Error: Could not load table content.</p>`;
            }
        };

        const closeModal = (value) => {
            document.body.removeChild(modal);
            resolve(value);
        };
        
        // --- 3. Event Listeners ---
        tableSelect.addEventListener('change', () => fetchAndDisplayTableContent(tableSelect.value));
        
        tableDisplay.addEventListener('click', (e) => {
            if (e.target && e.target.nodeName === 'TD') {
                const cellText = e.target.textContent.trim();
                const numericValue = parseFloat(cellText.replace(/,/g, '')); // Handle commas
                if (!isNaN(numericValue)) {
                    rateInput.value = numericValue;
                } else {
                    rateInput.value = '';
                    customAlert("Invalid selection. Please click a cell containing a number.");
                }
            }
        });

        modal.querySelector('#builderOkBtn').onclick = () => {
            const finalRate = parseFloat(rateInput.value);
            closeModal(isNaN(finalRate) ? null : finalRate);
        };
        modal.querySelector('#builderCancelBtn').onclick = () => closeModal(null);

        // --- 4. Initial Call ---
        populateTableSelect();
        fetchAndDisplayTableContent(null);
    });
}

         // REPLACE the existing choicePrompt function with this one
function choicePrompt(title, message, choices) {
    return new Promise(resolve => {
        const modalContainer = document.createElement('div');
        modalContainer.className = 'modal-container';

        // Create the HTML for all the choice buttons
        let buttonsHTML = choices.map(choice => 
            `<button id="${choice.id}" style="background-color:${choice.color || '#007bff'}">${choice.text}</button>`
        ).join('');

        // Set the complete modal content
        modalContainer.innerHTML = `
            <div class="modal-content">
                <h3>${title}</h3>
                <p>${message}</p>
                <div class="modal-buttons">
                    ${buttonsHTML}
                </div>
            </div>`;
        
        document.body.appendChild(modalContainer);

        const closeModal = (value) => {
            document.body.removeChild(modalContainer);
            resolve(value);
        };

        // Add a click event listener for each button
        choices.forEach(choice => {
            modalContainer.querySelector(`#${choice.id}`).onclick = () => closeModal(choice.id);
        });
    });
}

         function promptForRebarPattern(shapeType) {
             return new Promise(resolve => {
                 const isArea = shapeType === 'polygon' || shapeType === 'circle';
                 const isLine = shapeType === 'polyline';
                 if (!isArea && !isLine) { resolve(null); return; }
                 const m = document.createElement('div');
                 m.className = 'modal-container';
                 let htmlContent = '<h3>Rebar Pattern Generator</h3>';
                 const rebarDiameterOptions = REBAR_DIAMETERS.map(d => `<option value="${d}">${d}mm</option>`).join('');
                 if (isArea) { htmlContent += `<p><strong>Primary Mat</strong></p><label>Diameter:</label><select id="rebarDia1">${rebarDiameterOptions}</select><label>Spacing (mm):</label><input type="number" id="rebarSpacing1" value="150"><p style="margin-top:15px"><strong>Secondary Mat</strong></p><label>Diameter:</label><select id="rebarDia2">${rebarDiameterOptions}</select><label>Spacing (mm):</label><input type="number" id="rebarSpacing2" value="150">`; }
                 else { htmlContent += `<p><strong>Longitudinal Bars</strong></p><label>Number:</label><input type="number" id="longBarCount" value="4"><label>Diameter:</label><select id="longBarDia">${rebarDiameterOptions}</select><p style="margin-top:15px"><strong>Ties</strong></p><label>Diameter:</label><select id="tieDia">${rebarDiameterOptions}</select><label>Spacing (mm):</label><input type="number" id="tieSpacing" value="200">`; }
                 const c = document.createElement('div'); c.className = 'modal-content'; c.innerHTML = `${htmlContent}<div class="modal-buttons"><button id="modalOk">OK</button><button id="modalCancel">Cancel</button></div>`; m.appendChild(c); document.body.appendChild(m);
                 const closeModal = (value) => { document.body.removeChild(m); resolve(value); };
                 c.querySelector('#modalOk').onclick = () => {
                     let config = { type: 'pattern', pattern: isArea ? 'area' : 'line' };
                     if (isArea) { config.dia1 = parseFloat(c.querySelector('#rebarDia1').value); config.spacing1 = parseFloat(c.querySelector('#rebarSpacing1').value); config.dia2 = parseFloat(c.querySelector('#rebarDia2').value); config.spacing2 = parseFloat(c.querySelector('#rebarSpacing2').value); }
                     else { config.longBarCount = parseInt(c.querySelector('#longBarCount').value, 10); config.longBarDia = parseFloat(c.querySelector('#longBarDia').value); config.tieDia = parseFloat(c.querySelector('#tieDia').value); config.tieSpacing = parseFloat(c.querySelector('#tieSpacing').value); }
                     closeModal(config);
                 };
                 c.querySelector('#modalCancel').onclick = () => closeModal(null);
             });
         }
 
         // --- *** NEW *** Drawing Management ---
         function addNewDrawing(name, dataURL) {
             const img = new Image();
             img.onload = () => {
                 drawings[name] = {
                     img: img,
                     scale: 1,
                     originX: 0,
                     originY: 0,
                     pixelsPerMeter: 1,
                     layers: {},
                     currentLayerName: 'Default'
                 };
                 drawings[name].layers['Default'] = { shapes: [], visible: true };
                 switchDrawing(name);
                 updateDrawingUI();
                 fullClear3DScene();
                 resetCurrentShape();
                 draw();
                 drawTotalsBox();
             };
             img.src = dataURL;
         }
 
         function switchDrawing(name) {
             if (!drawings[name]) return;
             activeDrawingName = name;
             
             // Reset modes when switching
             scaleMode = false;
             exitCopyMoveMode();
             if (rebarMode.active) exitRebarMode(false); // silently exit rebar mode
 
             updateDrawingUI();
             updateLayerUI();
             resetCurrentShape();
             if (is3DMode) renderAllShapesIn3D(); // Re-render 3D for new drawing
             
             draw();
             drawTotalsBox();
         }
 
         function updateDrawingUI() {
             const drawingSelect = document.getElementById('drawingSelect');
             drawingSelect.innerHTML = '';
             for (const name in drawings) {
                 const option = document.createElement('option');
                 option.value = name;
                 option.textContent = name;
                 if (name === activeDrawingName) option.selected = true;
                 drawingSelect.appendChild(option);
             }
         }
 
         // --- Layer Management ---
         function addLayer(name, setActive = true) {
             if (!activeDrawingName || !name || drawings[activeDrawingName].layers[name]) {
                 customAlert(`Layer "${name}" already exists or name is invalid.`);
                 return;
             }
             drawings[activeDrawingName].layers[name] = { shapes: [], visible: true };
             if (setActive) drawings[activeDrawingName].currentLayerName = name;
             updateLayerUI();
         }
 
// REPLACE the old updateLayerUI function with this one
function updateLayerUI() {
    if (!activeDrawingName) return;
    const layerList = document.getElementById('layerList');
    const activeDrawing = drawings[activeDrawingName];

    layerList.innerHTML = ''; // Clear the list first

    for (const name in activeDrawing.layers) {
        const layer = activeDrawing.layers[name];
        const listItem = document.createElement('li');
        if (name === activeDrawing.currentLayerName) {
            listItem.className = 'active-layer';
        }

        // Checkbox for visibility
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = layer.visible;
        checkbox.onclick = (e) => {
            e.stopPropagation(); // Prevent the click from selecting the layer
            layer.visible = checkbox.checked;
            if (is3DMode) renderAllShapesIn3D();
            draw();
            drawTotalsBox(); // Recalculate totals
        };
        listItem.appendChild(checkbox);

        // Label for the layer name (makes the whole row clickable)
        const label = document.createElement('span');
        label.textContent = name;
        label.style.flexGrow = '1';
        listItem.appendChild(label);

        // Click event for the whole list item to set the active layer
        listItem.onclick = () => {
            activeDrawing.currentLayerName = name;
            updateLayerUI(); // Redraw the UI to show the new active layer
        };

        layerList.appendChild(listItem);
    }
}



// --- *** NEW: BOQ LOGIC START *** ---
let activeBoqCell = null; // This will store the currently selected table cell

/**
 * Calculates and updates the 'Amount' cell for a given BOQ row.
 */

 function calculateBoqTotal() {
    const boqTableBody = document.getElementById('boqTableBody');
    const rows = boqTableBody.querySelectorAll('tr');
    let total = 0;

    rows.forEach(row => {
        const amountCell = row.children[4];
        const amount = parseFloat(amountCell.textContent);
        if (!isNaN(amount)) {
            total += amount;
        }
    });

    document.getElementById('boqTotalAmount').textContent = total.toFixed(2);
}

// REPLACE this function
function updateBoqRowAmount(row) {
    const qtyCell = row.children[1];
    const rateCell = row.children[3];
    const amountCell = row.children[4];

    const qty = parseFloat(qtyCell.textContent);
    const rate = parseFloat(rateCell.textContent);

    if (!isNaN(qty) && !isNaN(rate)) {
        amountCell.textContent = (qty * rate).toFixed(2);
    } else {
        amountCell.textContent = '';
    }

    calculateBoqTotal(); // <-- ADD THIS LINE to update the total
}

/**
 * NEW: Asks user for format and triggers the appropriate export function.
 */
async function handleBoqExport() {
    const format = await choicePrompt("Export BOQ", "Choose an export format:", [
        {id: 'excel', text: 'Export to Excel', color: '#1e8e3e'},
        {id: 'pdf', text: 'Export to PDF', color: '#c9342d'},
        {id: 'cancel', text: 'Cancel', color: '#777'}
    ]);

    if (format === 'excel') {
        exportBoqToExcel();
    } else if (format === 'pdf') {
        exportBoqToPdf();
    }
}

/**
 * Exports the current BOQ table data to an XLSX file.
 */
function exportBoqToExcel() {
    const boqTable = document.querySelector('.boq-table');
    const fileName = "BOQ_Export.xlsx";
    const wb = XLSX.utils.table_to_book(boqTable, { sheet: "BOQ" });
    XLSX.writeFile(wb, fileName);
    customAlert(`BOQ has been exported successfully as ${fileName}`);
}

/**
 * NEW: Exports the current BOQ table to a printable PDF format.
 */
function exportBoqToPdf() {
    const boqTable = document.getElementById('boqTableBody').parentElement;
    
    // Define the specific styles for the PDF output
    const pdfStyles = `
        body { font-family: Arial, sans-serif; }
        h2 { text-align: center; margin-bottom: 20px; }
        table {
            width: 90%;
            margin: 5%;
            border-collapse: collapse;
            border: 2px solid black; /* Outer border */
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-left: 1px solid black;
            border-right: 1px solid black;
            /* NO horizontal line/border */
        }
        th {
            background-color: #e0e0e0;
            border-bottom: 2px solid black;
            font-weight: bold;
        }
    `;
    
    // Clone the table to avoid modifying the original and remove interactive elements
    const tableClone = boqTable.cloneNode(true);
    tableClone.querySelectorAll('[contenteditable="true"]').forEach(el => el.removeAttribute('contenteditable'));

    const printHtml = `
        <!DOCTYPE html>
        <html>
        <head>
            <title>Bill of Quantities</title>
            <style>${pdfStyles}</style>
        </head>
        <body>
            <h2>Bill of Quantities</h2>
            ${tableClone.outerHTML}
        </body>
        </html>
    `;
    
    // Open a new window, write the HTML, and trigger the print dialog
    const printWindow = window.open('', '_blank');
    printWindow.document.open();
    printWindow.document.write(printHtml);
    printWindow.document.close();
    
    setTimeout(() => {
        printWindow.focus();
        printWindow.print();
        printWindow.close();
    }, 500); // Timeout allows the content to render properly
}


function setupBoq() {
    const boqModal = document.getElementById('boqModal');
    const showBoqBtn = document.getElementById('showBoqBtn');
    const closeBoqBtn = document.getElementById('closeBoqBtn');
    const addBoqRowBtn = document.getElementById('addBoqRowBtn');
    const boqTableBody = document.getElementById('boqTableBody');
    const exportBtn = document.getElementById('exportBoqBtn');

    showBoqBtn.addEventListener('click', () => { boqModal.style.display = 'flex'; });
    closeBoqBtn.addEventListener('click', () => { boqModal.style.display = 'none'; });
    addBoqRowBtn.addEventListener('click', addBoqRow);
    exportBtn.addEventListener('click', handleBoqExport);

    boqTableBody.addEventListener('click', async (e) => {
        // --- NEW: Handle row deletion ---
        const deleteBtn = e.target.closest('.delete-boq-row');
        if (deleteBtn) {
            const row = deleteBtn.closest('tr');
            if (row) {
                row.remove();
                calculateBoqTotal();
            }
            return; // Stop processing to avoid other click actions
        }

        // Handle quantity cell selection
        if (e.target && e.target.classList.contains('quantity-cell')) {
            if (activeBoqCell) activeBoqCell.classList.remove('boq-cell-active');
            activeBoqCell = e.target;
            activeBoqCell.classList.add('boq-cell-active');
        } else {
            if (activeBoqCell) activeBoqCell.classList.remove('boq-cell-active');
            activeBoqCell = null;
        }

        // Handle clicking a rate cell to open the rate builder
        if (e.target && e.target.classList.contains('rate-cell')) {
            const targetCell = e.target;
            const parentRow = targetCell.parentElement;
            const description = parentRow.children[0].textContent;
            
            const newRate = await showRateBuilder(description);
            
            if (newRate !== null) {
                targetCell.textContent = newRate.toFixed(2);
                updateBoqRowAmount(parentRow);
            }
        }
    });

    boqTableBody.addEventListener('input', (e) => {
        if (e.target && (e.target.classList.contains('quantity-cell') || e.target.classList.contains('rate-cell'))) {
            const parentRow = e.target.parentElement;
            updateBoqRowAmount(parentRow);
        }
    });

    document.getElementById('totalQuantitiesBox').addEventListener('click', handleQuantityClick);
    document.getElementById('rebarQuantitiesBox').addEventListener('click', handleQuantityClick);
}

// REPLACE this function
// Estimator8.0.html

// REPLACE THIS ENTIRE FUNCTION
// transition UIX file.html

// REPLACE THIS ENTIRE FUNCTION
async function handleQuantityClick(e) {
    if (!e.target || !e.target.classList.contains('quantity-value')) return;

    let value = parseFloat(e.target.textContent);
    let unit = e.target.dataset.unit;
    const type = e.target.dataset.type; 

    // --- MODIFICATION START ---
    // Check if the type is 'Total Count' and adjust the unit
    if (type === 'Total Count') {
        unit = 'Item';
    }

    // Round the value up to the nearest whole number, with a minimum of 1
    const finalValue = Math.max(1, Math.round(value));
    // --- MODIFICATION END ---

    if (isAggregating) {
        if (aggregator.unit === null) {
            aggregator.unit = unit;
            aggregator.sum = finalValue; // Use finalValue
        } else if (aggregator.unit === unit) {
            aggregator.sum += finalValue; // Use finalValue
        } else {
            customAlert(`Unit Mismatch! Cannot aggregate quantities with different units.`);
            return;
        }
        document.getElementById('aggregatorUnit').textContent = aggregator.unit;
        document.getElementById('aggregatorSum').textContent = aggregator.sum.toFixed(0); // Show sum as whole number
    } else if (isDeducting) {
        customAlert("Deduct mode is active. Please draw shapes to deduct area.");
    } else if (activeBoqCell) {
        const parentRow = activeBoqCell.parentElement;
        activeBoqCell.textContent = finalValue; // Use finalValue
        parentRow.children[2].textContent = unit;
        updateBoqRowAmount(parentRow);
        activeBoqCell.classList.remove('boq-cell-active');
        activeBoqCell = null;
    } else {
        const choice = await choicePrompt("Action", "No BOQ cell is selected. What would you like to do?", [
            {id: 'scratchpad', text: 'Add to Scratchpad', color: '#007bff'},
            {id: 'cancel', text: 'Cancel', color: '#777'}
        ]);

        if (choice === 'scratchpad') {
            const description = await customPrompt("Add to Scratchpad", "Enter a description for this value:", type || "New Item");
            if (description) { 
                scratchpadData.push({
                    description: description,
                    value: finalValue, // Use finalValue
                    unit: unit
                });
                renderScratchpad();
                customAlert("Value added to scratchpad.");
            }
        }
    }
}

function addBoqRow() {
    const boqTableBody = document.getElementById('boqTableBody');
    const newRow = boqTableBody.insertRow();
    
    const cellDesc = newRow.insertCell(0);
    const cellQty = newRow.insertCell(1);
    const cellUnit = newRow.insertCell(2);
    const cellRate = newRow.insertCell(3);
    const cellAmount = newRow.insertCell(4);
    const cellActions = newRow.insertCell(5); // This line was missing

    cellDesc.contentEditable = "true";
    cellDesc.textContent = "Click to edit description...";
    
    cellRate.textContent = "0.00"; 
    cellRate.style.cursor = "pointer";
    cellRate.title = "Click to select rate from database";

    // This section will now work correctly
    cellActions.innerHTML = `<button class="delete-boq-row" title="Delete Row" style="background:none; border:none; color:#E74C3C; cursor:pointer; font-size: 14px;"><i class="fas fa-trash-alt"></i></button>`;
    cellActions.style.textAlign = 'center';

    // These classes will now be added, fixing the cell activation issue
    cellQty.classList.add('quantity-cell');
    cellUnit.classList.add('unit-cell');
    cellRate.classList.add('rate-cell');
    cellAmount.classList.add('amount-cell');
}

// --- *** NEW: BOQ LOGIC END *** ---


        // --- PASTE THE NEW FUNCTION HERE ---
function showSmmBuilder() {
    // Add this check at the very beginning of the function
    const statusText = document.getElementById('smmDbStatus').textContent;
    if (!statusText.startsWith('Connected')) {
        customAlert("Please load an SMM database first using the controls at the top.");
        return Promise.resolve(null); // Immediately cancel the promise
    }
    
    return new Promise(resolve => {
        const modal = document.getElementById('smmModal');
        const optionsContainer = document.getElementById('smm-options');
        // ... all the code for showSmmBuilder ...
    });
}
// --- END OF PASTED FUNCTION ---

// --- *** NEW: AGGREGATOR LOGIC START *** ---
let isAggregating = false;
let aggregator = { sum: 0, unit: null };

function toggleAggregationMode(forceOff = false) {
    isAggregating = forceOff ? false : !isAggregating;
    const aggregatorBox = document.getElementById('aggregatorBox');
    const toggleBtn = document.getElementById('toggleAggregateBtn');

    if (isAggregating) {
        // Reset state and show UI
        aggregator = { sum: 0, unit: null };
        document.getElementById('aggregatorUnit').textContent = 'N/A';
        document.getElementById('aggregatorSum').textContent = '0.00';
        aggregatorBox.style.display = 'block';
        toggleBtn.style.backgroundColor = '#2ECC71'; // Green to indicate it's active
        toggleBtn.innerHTML = '<i class="fas fa-check"></i> Finish';
        customAlert('Aggregation mode is ON. Click on quantities to add them. You can only sum quantities with the same unit.');
    } else {
        // Hide UI
        aggregatorBox.style.display = 'none';
        toggleBtn.style.backgroundColor = '#E67E22'; // Back to default orange
        toggleBtn.innerHTML = '<i class="fas fa-calculator"></i> Aggregate';
    }
}

async function applyAggregation() {
    if (!activeBoqCell) {
        customAlert("Please click on a 'Quantity' cell in the BOQ table first to select a destination.");
        return;
    }
    if (aggregator.sum <= 0) {
        customAlert("No quantities have been aggregated. Click on values in the take-off boxes to add them.");
        return;
    }

    const multiplierStr = await customPrompt("Apply Multiplier", `The aggregated sum is ${aggregator.sum.toFixed(2)} ${aggregator.unit}. \n\nEnter a multiplier (e.g., for 4 identical units, enter 4):`, "1");
    const multiplier = parseFloat(multiplierStr) || 1;
    const finalValue = aggregator.sum * multiplier;

    const parentRow = activeBoqCell.parentElement;
    activeBoqCell.textContent = finalValue.toFixed(2);
    parentRow.children[2].textContent = aggregator.unit;

    updateBoqRowAmount(parentRow);
    toggleAggregationMode(true); // Force off and reset
}


function setupAggregatorControls() {
    document.getElementById('toggleAggregateBtn').addEventListener('click', () => toggleAggregationMode());
    document.getElementById('cancelAggregateBtn').addEventListener('click', () => toggleAggregationMode(true));
    document.getElementById('applyAggregateBtn').addEventListener('click', applyAggregation);
    
    // ADD THIS LINE to prevent clicks from falling through to the canvas
    document.getElementById('aggregatorBox').addEventListener('mousedown', (e) => e.stopPropagation());
}
// --- *** NEW: AGGREGATOR LOGIC END *** ---

function setupDeductorControls() {
    document.getElementById('toggleDeductBtn').addEventListener('click', () => toggleDeductMode());
    document.getElementById('cancelDeductBtn').addEventListener('click', () => toggleDeductMode(true)); // forceOff
    document.getElementById('applyDeductBtn').addEventListener('click', applyDeduction);

    // ADD THIS LINE to prevent clicks from falling through to the canvas
    document.getElementById('deductorBox').addEventListener('mousedown', (e) => e.stopPropagation());
}

function toggleDeductMode(forceOff = false) {
    if (!forceOff && isAggregating) {
        toggleAggregationMode(true);
    }
    isDeducting = forceOff ? false : !isDeducting;
    const deductorBox = document.getElementById('deductorBox');
    const toggleBtn = document.getElementById('toggleDeductBtn');

    if (isDeducting) {
        // Reset the state to handle shape objects
        deductor = { primaryShape: null, deductionShapes: [], stage: 'primary', tempShapes: [] };
        
        // Update the UI
        document.getElementById('deductorPrimary').textContent = '0.00';
        document.getElementById('deductorUnit').textContent = 'N/A';
        document.getElementById('deductorSum').textContent = '0.00';
        deductorBox.style.display = 'block';
        toggleBtn.style.backgroundColor = '#E74C3C';
        toggleBtn.innerHTML = '<i class="fas fa-check"></i> Finalize';
        
        customAlert('Deduct Mode ON: Draw the primary (gross) element now. Press "Enter" to finalize it.');
    } else {
        deductorBox.style.display = 'none';
        toggleBtn.style.backgroundColor = '#F39C12';
        toggleBtn.innerHTML = '<i class="fas fa-minus-circle"></i> Deduct';
        // Clear any temporary shapes from the canvas when exiting
        draw(); 
    }
}


async function applyDeduction() {
    if (!deductor.primaryShape) {
        customAlert("No primary element has been drawn. Please draw the gross area shape first.");
        return;
    }
    if (!activeDrawingName) return;
    const activeDrawing = drawings[activeDrawingName];

    // --- Prompt for final element properties, similar to finalizeShape ---
    const defaultName = deductor.primaryShape.type === 'polyline' ? "Wall with Openings" : "Slab with Openings";
    const nI = await customPrompt("Final Element Properties", "Enter Element Name:", defaultName);
    if (!nI) { toggleDeductMode(true); return; }
    
    const desc = await showDescriptionBuilder();
    
    // Combine the primary shape with its deductions (holes)
    let finalShape = {
        ...deductor.primaryShape,
        holes: deductor.deductionShapes, // Attach holes for 3D rendering
        name: nI,
        color: getElementColor(nI),
        description: desc || '',
        copyCount: 1,
    };

    const el = await customPrompt("Element Properties", "Enter Base Elevation (m):", "0.0");
    if (el === null) { toggleDeductMode(true); return; }
    finalShape.baseElevation = parseFloat(el) || 0;
    
    const hI = await customPrompt("Element Properties", "Enter height/depth (m):", "0.2");
    if (hI === null) { toggleDeductMode(true); return; }
    finalShape.height = parseFloat(hI);
    
    // Add the completed shape to the drawing
    const currentLayerName = activeDrawing.currentLayerName;
    activeDrawing.layers[currentLayerName].shapes.push(finalShape);
    if (is3DMode) {
        addShapeTo3DScene(finalShape, activeDrawing.layers[currentLayerName].shapes.length - 1);
    }
    
    // Reset and exit deduct mode
    toggleDeductMode(true); 

    if (desc && desc.trim() !== '') {
        const boqChoice = await choicePrompt("Update BOQ", "Do you want to add the generated description to the BOQ now?", [
            {id: 'yes', text: 'Yes, Add to BOQ', color: '#4CAF50'}, {id: 'no', text: 'Not Now', color: '#777'}
        ]);
        if (boqChoice === 'yes') {
            await addDescriptionToBoq(desc);
        }
    }

    drawTotalsBox();
    draw();
}


// ADD THIS NEW FUNCTION to set up tooltips
// REPLACE THIS ENTIRE FUNCTION
function setupTooltips() {
    // An object mapping button IDs to their tooltip text
    const tooltips = {
        saveProjectBtn: 'Save Project (.q3d)',
        loadProjectBtn: 'Load Project (.q3d)',
        // The reference to the non-existent 'exportMatlabBtn' has been removed.
        importBtn: 'Import New Drawing (PDF/Image)',
        deleteDrawingBtn: 'Delete Current Drawing',
        addLayerBtn: 'Add New Layer',
        setScaleBtn: 'Set Scale from Drawing',
        copyMoveBtn: 'Copy & Move Shape',
        undoBtn: 'Undo Last Action',
        clearBtn: 'Clear All on Current Layer',
        toggle3D: 'Toggle 3D/2D View',
        showBoqBtn: 'Show Bill of Quantities',
        toggleAggregateBtn: 'Aggregate Multiple Quantities',
        loadSmmDbBtn: 'Load Selected Database'
    };

    // Initialize Tippy.js for each button with a title
    for (const id in tooltips) {
        const element = document.getElementById(id);
        if (element) {
            tippy(element, {
                content: tooltips[id],
                placement: 'top', 
                animation: 'scale-subtle',
                theme: 'translucent',
            });
        }
    }
}

// ADD THIS ENTIRE NEW FUNCTION
function setupPrecisionRuler() {
    const rulerContainer = document.getElementById('precisionRulerContainer');
    const track = document.getElementById('rulerTrack');
    const thumb = document.getElementById('rulerThumb');
    const valueInput = document.getElementById('rulerValueInput');

    const RULER_MIN = -1000000;
    const RULER_MAX = 1000000;
    const RULER_RANGE = RULER_MAX - RULER_MIN;

    let isDragging = false;

    // Function to update the ruler based on a numeric value
    function updateRulerFromValue(value) {
        // Clamp the value to the allowed range
        const clampedValue = Math.max(RULER_MIN, Math.min(RULER_MAX, value));
        valueInput.value = clampedValue;
        
        // Calculate the percentage position for the thumb
        const percentage = ((clampedValue - RULER_MIN) / RULER_RANGE) * 100;
        thumb.style.left = `${percentage}%`;
    }

    // Function to update the value based on the thumb's position
    function updateValueFromPosition(event) {
        const rect = track.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
        
        const value = Math.round(RULER_MIN + (percentage / 100) * RULER_RANGE);
        updateRulerFromValue(value);
    }
    
    // Event listeners
    track.addEventListener('mousedown', (e) => {
        isDragging = true;
        rulerContainer.style.cursor = 'ew-resize';
        updateValueFromPosition(e);
    });

    window.addEventListener('mousemove', (e) => {
        if (isDragging) {
            updateValueFromPosition(e);
        }
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        rulerContainer.style.cursor = 'default';
    });

    valueInput.addEventListener('change', () => {
        updateRulerFromValue(parseInt(valueInput.value, 10) || 0);
    });
    
    // Initialize
    updateRulerFromValue(200); // Default value
}

// ADD THIS NEW FUNCTION to handle the Ditto button's logic
async function handleDittoClick() {
    // 1. Check if the database is connected
    const statusText = document.getElementById('smmDbStatus').textContent;
    if (!statusText.startsWith('Connected')) {
        customAlert("Please load a database first to create a BOQ item.");
        return;
    }

    // 2. Open the description builder to get the item description
    const description = await showDescriptionBuilder();
    if (!description || description.trim() === '') {
        customAlert("Ditto cancelled: No description was provided.");
        return; // Exit if user cancels or enters nothing
    }

    // 3. Open the rate builder to get the item's rate
    const rate = await showRateBuilder(description);

    // 4. Add a new row to the BOQ table
    addBoqRow();
    const boqTableBody = document.getElementById('boqTableBody');
    const newRow = boqTableBody.lastChild; // Get the row that was just added

    // 5. Populate the new row with the selected description and rate
    newRow.children[0].textContent = description; // Description cell
    if (rate !== null) {
        newRow.children[3].textContent = rate.toFixed(2); // Rate cell
    }

    // 6. Automatically select the quantity cell of the new row
    if (activeBoqCell) {
        activeBoqCell.classList.remove('boq-cell-active');
    }
    activeBoqCell = newRow.children[1]; // The quantity cell
    activeBoqCell.classList.add('boq-cell-active');

    // 7. Show the BOQ and guide the user on the next step
    document.getElementById('boqModal').style.display = 'flex';
    await customAlert("Ditto item created. The quantity cell is now active. Click on any value in the take-off boxes to apply it.");
}

// transition UIX file.html

/**
 * Renders the scratchpad table from the scratchpadData array.
 */
/**
 * Renders the scratchpad table from the scratchpadData array.
 */
function renderScratchpad() {
    const tableBody = document.getElementById('scratchpadTableBody');
    tableBody.innerHTML = ''; // Clear existing rows
    if (scratchpadData.length === 0) {
        const row = tableBody.insertRow();
        const cell = row.insertCell(0);
        cell.colSpan = 2;
        cell.textContent = 'No items yet...';
        cell.style.textAlign = 'center';
        cell.style.fontStyle = 'italic';
    } else {
        scratchpadData.forEach((item, index) => {
            const row = tableBody.insertRow();
            row.insertCell(0).textContent = item.description;
            const valueCell = row.insertCell(1);
            // MODIFICATION: Display the unit next to the value
            valueCell.innerHTML = `<span class="quantity-value" data-unit="${item.unit}">${item.value.toFixed(2)} ${item.unit || ''}</span>`;
            valueCell.style.textAlign = 'right';
        });
    }
}

/**
 * Sets up event listeners for the scratchpad controls.
 */
/**
 * Sets up event listeners for the scratchpad controls.
 */
/**
 * Sets up event listeners for the scratchpad controls.
 */
function setupScratchpadControls() {
    document.getElementById('clearScratchpadBtn').addEventListener('click', async () => {
         const choice = await choicePrompt("Confirm Clear", "Are you sure you want to clear all items from the scratchpad?", [
            {id: 'yes', text: 'Yes, Clear', color: '#f44336'}, {id: 'no', text: 'Cancel', color: '#777'}
        ]);
        if (choice === 'yes') {
            scratchpadData = [];
            renderScratchpad();
        }
    });

    document.getElementById('calculateScratchpadBtn').addEventListener('click', async () => {
        if (scratchpadData.length === 0) {
            customAlert("Scratchpad is empty.");
            return;
        }
        
        const firstUnit = scratchpadData[0].unit;
        const hasMixedUnits = scratchpadData.some(item => item.unit !== firstUnit);
        
        let calculationResult = null;

        if (hasMixedUnits) {
            // MODIFICATION: Show selection modal for mixed units
            calculationResult = await showScratchpadSelectionModal(scratchpadData);
            if (!calculationResult) return; // User cancelled the selection modal
        } else {
            // Original logic for when all units are the same
            const total = scratchpadData.reduce((sum, item) => {
                if (item.description.includes('-')) return sum - item.value;
                return sum + item.value;
            }, 0);
            calculationResult = { total: total, unit: firstUnit };
        }

        const { total, unit } = calculationResult;
        let resultMessage = `Calculated Total: ${total.toFixed(2)} ${unit || ''}`;

        const choice = await choicePrompt("Calculation Complete", resultMessage, [
            {id: 'apply', text: 'Apply to BOQ', color: '#4CAF50'},
            {id: 'close', text: 'Close', color: '#777'}
        ]);

        if (choice === 'apply') {
            if (!activeBoqCell) {
                customAlert("Please click on a 'Quantity' cell in the BOQ table first to select a destination.");
                return;
            }

            // MODIFICATION: Round value to nearest whole number (minimum of 1)
            const finalValue = Math.max(1, Math.round(total));
            
            const parentRow = activeBoqCell.parentElement;
            activeBoqCell.textContent = finalValue; // Apply the rounded value
            parentRow.children[2].textContent = unit;
            
            updateBoqRowAmount(parentRow);
            activeBoqCell.classList.remove('boq-cell-active');
            activeBoqCell = null;
            customAlert("Value has been applied to the BOQ.");
        }
    });

    renderScratchpad();
}

// --- Initialization ---
    function setup() {
    setupBoq();
    setupSmmControls();
    setupAggregatorControls();
    setupDeductorControls();
    setupTooltips();
    setupPrecisionRuler();
    setupScratchpadControls(); // <--- ADD THIS LINE

    document.getElementById('rebarDiaSelect').innerHTML = REBAR_DIAMETERS.map(d => `<option value="${d}">${d}mm</option>`).join('');
    document.getElementById('rebarDrawModeSelect').addEventListener('change', (e) => switchRebarDrawingMode(e.target.value));
    document.getElementById('rebarDiaSelect').addEventListener('change', () => { if (rebarMode.active) resetCurrentRebarLine(); });
    document.getElementById('saveProjectBtn').addEventListener('click', saveProject);
     document.getElementById('dittoBtn').addEventListener('click', handleDittoClick); // <-- ADD THIS LINE
    document.getElementById('loadProjectBtn').addEventListener('click', () => document.getElementById('loadProjectInput').click());
    document.getElementById('loadProjectInput').addEventListener('change', loadProject);
    
    resetCurrentShape();
    window.addEventListener('resize', resize);
    document.getElementById('importBtn').addEventListener('click', () => document.getElementById('fileInput').click());
    document.getElementById('fileInput').addEventListener('change', async (e) => {
        const file = e.target.files[0]; if (!file) return;
        const drawingName = await customPrompt('New Drawing', 'Enter a name for this drawing:', `Drawing ${Object.keys(drawings).length + 1}`);
        if (!drawingName || drawings[drawingName]) {
            customAlert('Invalid or duplicate drawing name.');
            e.target.value = '';
            return;
        }
        if (file.type.startsWith('image/')) { 
            const reader = new FileReader(); 
            reader.onload = (event) => addNewDrawing(drawingName, event.target.result); 
            reader.readAsDataURL(file); 
        } else if (file.type === 'application/pdf') { 
            handlePdfFile(file, drawingName); 
        } else { 
            customAlert('Unsupported file type. Please select an image or PDF file.'); 
        }
        e.target.value = '';
    });
    document.getElementById('drawingSelect').addEventListener('change', (e) => switchDrawing(e.target.value));
    document.getElementById('deleteDrawingBtn').addEventListener('click', async () => {
        if (!activeDrawingName || Object.keys(drawings).length <= 1) {
            customAlert('Cannot delete the last drawing.');
            return;
        }
        const choice = await choicePrompt('Confirm Delete', `Are you sure you want to permanently delete the drawing "${activeDrawingName}"?`, [
            {id: 'yes', text: 'Yes, Delete', color: '#f44336'}, {id: 'no', text: 'Cancel', color: '#777'}
        ]);
        if (choice === 'yes') {
            delete drawings[activeDrawingName];
            activeDrawingName = Object.keys(drawings)[0];
            switchDrawing(activeDrawingName);
        }
    });
    document.getElementById('setScaleBtn').addEventListener('click', () => {
        if (!activeDrawingName) return;
        scaleMode = true;
        scalePoints = [];
        resetCurrentShape();
        draw();
    });
    document.getElementById('shapeType').addEventListener('change', (e) => {
        exitCopyMoveMode();
        resetCurrentShape();
        canvas.style.cursor = e.target.value === 'eraser' ? 'cell' : 'crosshair';
    });
    document.getElementById('toggleCurveBtn').addEventListener('click', toggleCurveMode);
    document.getElementById('copyMoveBtn').addEventListener('click', () => {
        copyMoveMode.active = !copyMoveMode.active;
        if (copyMoveMode.active) {
            customAlert('Copy & Move mode activated. Click a shape to copy it.');
            canvas.style.cursor = 'copy';
            resetCurrentShape();
        } else {
            exitCopyMoveMode();
        }
    });
    document.getElementById('undoBtn').addEventListener('click', () => {
         if (!activeDrawingName) return;
         const activeDrawing = drawings[activeDrawingName];
         if (currentShape.points.length > 0) { currentShape.points.pop(); }
         else if (activeDrawing.layers[activeDrawing.currentLayerName] && activeDrawing.layers[activeDrawing.currentLayerName].shapes.length > 0) {
            const rem = activeDrawing.layers[activeDrawing.currentLayerName].shapes.pop();
            if (rem._3DObject && scene) scene.remove(rem._3DObject);
         }
         draw(); drawTotalsBox();
    });
    document.getElementById('clearBtn').addEventListener('click', async () => {
        if (!activeDrawingName) return;
        const activeDrawing = drawings[activeDrawingName];
        const choice = await choicePrompt('Confirm Clear', `Are you sure you want to clear all shapes on layer "${activeDrawing.currentLayerName}"?`, [
            {id: 'yes', text: 'Yes, Clear Layer', color: '#f44336'},
            {id: 'no', text: 'Cancel', color: '#777'}
        ]);
        if (choice === 'yes') {
             if (activeDrawing.layers[activeDrawing.currentLayerName]) {
                if (scene) activeDrawing.layers[activeDrawing.currentLayerName].shapes.forEach(s => { if(s._3DObject) scene.remove(s._3DObject); });
                
                if (activeDrawing.currentLayerName !== 'Default') {
                    delete activeDrawing.layers[activeDrawing.currentLayerName];
                    activeDrawing.currentLayerName = 'Default';
                    updateLayerUI();
                } else {
                    activeDrawing.layers[activeDrawing.currentLayerName].shapes = [];
                }
             }
             resetCurrentShape();
             draw();
             drawTotalsBox();
        }
    });
    document.getElementById('toggle3D').addEventListener('click', toggle3DView);
    document.getElementById('finishRebarBtn').addEventListener('click', () => exitRebarMode(true));
   document.getElementById('addNewLayerBtn').addEventListener('click', async () => {
    if (!activeDrawingName) return;
    const name = await customPrompt('New Layer', 'Enter a name for the new layer:', `Layer ${Object.keys(drawings[activeDrawingName].layers).length + 1}`);
    if (name) addLayer(name);
});
   
    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('wheel', onWheel);
    canvas.addEventListener('click', onClick);
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    window.addEventListener('keydown', onKeyDown);
    addNewDrawing('Default Drawing', ''); 
    resize();
}
 
         // --- MODIFICATION START: Add the new function to toggle curve mode ---
function toggleCurveMode(setActive = !isCurveMode) {
    isCurveMode = setActive;
    const btn = document.getElementById('toggleCurveBtn');
    if (isCurveMode) {
        btn.style.backgroundColor = '#26C6DA'; // A bright color to indicate active
        customAlert('Curve mode ON. First click sets the control point, then click the end point.');
    } else {
        btn.style.backgroundColor = '#90A4AE'; // Default color
        tempControlPoint = null; // Clear any pending control point
    }
}
// --- MODIFICATION END ---

         function resetCurrentShape() { 
             currentShape = { type: document.getElementById('shapeType').value, points: [], isClosed: false, height: null, baseElevation: 0, radius: null, center: null, name: null, color: null, rebar: null, description: '' }; 
             angleIndicator.style.visibility = 'hidden';
             if (isCurveMode) {
                 toggleCurveMode(false); // Turn off and reset button color
             }
             tempControlPoint = null;
         }
         
         function exitCopyMoveMode() {
             copyMoveMode = { active: false, shape: null, grabPoint: null };
             canvas.style.cursor = 'crosshair';
             document.getElementById('copyMoveBtn').style.backgroundColor = '#ff9800';
             draw();
         }
 
         function resetCurrentRebarLine() { currentRebarLine = { points: [], dia: parseFloat(document.getElementById('rebarDiaSelect').value) }; }
         function resetCurrentStirrupShape() { currentStirrupShape = { points: [], isClosed: false }; }
         function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; if (renderer && camera) { const w = threeDContainer.clientWidth, h = threeDContainer.clientHeight; renderer.setSize(w, h); camera.aspect = w / h; camera.updateProjectionMatrix(); } draw(); drawTotalsBox(); }
 
         // --- Main Drawing Loop ---
         function draw(cursorX = null, cursorY = null) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!activeDrawingName) return;
    const activeDrawing = drawings[activeDrawingName];
    const { img, originX, originY, scale, layers } = activeDrawing;

    ctx.globalAlpha = rebarMode.active ? 0.3 : 1.0;
    ctx.translate(originX, originY);
    ctx.scale(scale, scale);
    if (img && img.src) ctx.drawImage(img, 0, 0);

    for (const name in layers) {
        if (layers[name].visible) {
            layers[name].shapes.forEach(s => drawShape(s, s.color, new THREE.Color(s.color).getStyle() + '40'));
        }
    }
    
    // --- NEW: Draw temporary shapes for Deduct Mode ---
    if (isDeducting && deductor.tempShapes.length > 0) {
        deductor.tempShapes.forEach(s => {
            // Draw deductions with a semi-transparent fill to look like holes
            const fillColor = s.color === '#f44336' ? 'rgba(50, 50, 50, 0.7)' : 'transparent';
            drawShape(s, s.color, fillColor, 3);
        });
    }
    // --- END OF ADDITION ---
    
    ctx.globalAlpha = 1.0;

    if (rebarMode.active) {
        if(rebarMode.parentShape) drawShape(rebarMode.parentShape, rebarMode.parentShape.color, new THREE.Color(rebarMode.parentShape.color).getStyle() + '60', 4);
        if (rebarMode.drawingMode === 'planar') drawShape(currentRebarLine, '#FFD700', 'transparent', 2);
        if (rebarMode.drawingMode === 'stirrup') drawShape(currentStirrupShape, '#00FFFF', 'transparent', 2);
    } else if (copyMoveMode.active && copyMoveMode.shape) {
        drawShape(copyMoveMode.shape, 'lime', 'rgba(0, 255, 0, 0.3)');
    } else {
        drawShape(currentShape, 'orange', 'transparent');
    }

    if (cursorX !== null) {
        const mouseImgX = (cursorX - originX) / scale, mouseImgY = (cursorY - originY) / scale;
        ctx.setLineDash([5, 5]); ctx.lineWidth = 1.5 / scale;
        let lastPoint;
        if (rebarMode.active && rebarMode.drawingMode === 'planar' && currentRebarLine.points.length > 0) {
             lastPoint = currentRebarLine.points[currentRebarLine.points.length-1];
             ctx.strokeStyle = '#FFD700';
        } else if (rebarMode.active && rebarMode.drawingMode === 'stirrup' && currentStirrupShape.points.length > 0) {
             lastPoint = currentStirrupShape.points[currentStirrupShape.points.length-1];
             ctx.strokeStyle = '#00FFFF';
        } else if (!rebarMode.active && !copyMoveMode.active && !scaleMode && !isDrawingFreehand && currentShape.points && currentShape.points.length > 0 && currentShape.type !== 'count' && currentShape.type !== 'eraser') {
             lastPoint = currentShape.points[currentShape.points.length-1];
             ctx.strokeStyle = 'red';
        }

        if (lastPoint) {
           if (isCurveMode && tempControlPoint) {
               ctx.beginPath();
               ctx.moveTo(lastPoint.x, lastPoint.y);
               ctx.quadraticCurveTo(tempControlPoint.x, tempControlPoint.y, mouseImgX, mouseImgY);
               ctx.strokeStyle = '#26C6DA';
               ctx.stroke();
           } else if (isCurveMode && !tempControlPoint) {
                ctx.beginPath(); 
                ctx.moveTo(lastPoint.x, lastPoint.y); 
                ctx.lineTo(mouseImgX, mouseImgY); 
                ctx.strokeStyle = '#FFD700';
                ctx.stroke();
           } else {
                ctx.beginPath(); 
                ctx.moveTo(lastPoint.x, lastPoint.y); 
                ctx.lineTo(mouseImgX, mouseImgY); 
                ctx.strokeStyle = 'red';
                ctx.stroke();
           }
        }
        ctx.setLineDash([]);

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (document.getElementById('shapeType').value === 'eraser') {
            ctx.beginPath();
            ctx.arc(cursorX, cursorY, ERASER_RADIUS, 0, 2 * Math.PI);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.stroke();
        } else if (!scaleMode) {
            ctx.beginPath(); ctx.moveTo(cursorX, 0); ctx.lineTo(cursorX, canvas.height);
            ctx.moveTo(0, cursorY); ctx.lineTo(canvas.width, cursorY);
            ctx.strokeStyle = 'red'; ctx.lineWidth = 1; ctx.stroke();
        }
    }
}
        // Estimator8.0.html

// REPLACE THIS FUNCTION
function drawShape(shape, strokeColor, fillColor, lineWidth = 2) {
    if (!activeDrawingName || !shape || (!shape.points && !shape.center)) return;
    const scale = drawings[activeDrawingName].scale;
    ctx.strokeStyle = strokeColor;
    ctx.fillStyle = fillColor;
    ctx.lineWidth = lineWidth / scale;

    if (shape.type === 'circle' && shape.center && shape.radius) {
        ctx.beginPath();
        ctx.arc(shape.center.x, shape.center.y, shape.radius, 0, 2 * Math.PI);
        ctx.stroke();
        if (fillColor !== 'transparent') ctx.fill();
    } else if (shape.type === 'count' && shape.points) {
        const crossSize = 10 / scale;
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = lineWidth / scale;
        shape.points.forEach(p => {
            ctx.beginPath();
            ctx.moveTo(p.x - crossSize / 2, p.y - crossSize / 2);
            ctx.lineTo(p.x + crossSize / 2, p.y + crossSize / 2);
            ctx.moveTo(p.x + crossSize / 2, p.y - crossSize / 2);
            ctx.lineTo(p.x - crossSize / 2, p.y + crossSize / 2);
            ctx.stroke();
        });
    } else if (shape.points && shape.points.length > 0) {
        ctx.beginPath();
        ctx.moveTo(shape.points[0].x, shape.points[0].y);
        for (let i = 1; i < shape.points.length; i++) {
            const p = shape.points[i];
            if (p.isCurve) {
                ctx.quadraticCurveTo(p.cpx, p.cpy, p.x, p.y);
            } else {
                ctx.lineTo(p.x, p.y);
            }
        }
        if (shape.isClosed) ctx.closePath();

        // --- NEW: Draw 2D holes ---
        if (shape.isClosed && shape.holes && Array.isArray(shape.holes)) {
            shape.holes.forEach(holeShape => {
                if (holeShape.points && holeShape.points.length > 2) {
                    ctx.moveTo(holeShape.points[0].x, holeShape.points[0].y);
                    for (let i = 1; i < holeShape.points.length; i++) {
                        const p = holeShape.points[i];
                        if (p.isCurve) {
                            ctx.quadraticCurveTo(p.cpx, p.cpy, p.x, p.y);
                        } else {
                            ctx.lineTo(p.x, p.y);
                        }
                    }
                    ctx.closePath();
                }
            });
        }

        ctx.stroke();
        if (fillColor !== 'transparent' && shape.isClosed) {
            // The fill command now correctly handles holes using the non-zero winding rule.
            ctx.fill();
        }
    }

    if (shape.rebar) {
        // ... (The entire rebar drawing block remains unchanged) ...
        if (shape.rebar.bars) shape.rebar.bars.forEach(bar => {
            if (bar.points) {
                ctx.strokeStyle = '#A9A9A9'; ctx.lineWidth = (bar.dia / 5) / scale;
                ctx.beginPath(); bar.points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)); ctx.stroke();
            } else if (bar.position) {
                ctx.fillStyle = '#8B4513'; ctx.strokeStyle = '#D2B48C'; ctx.lineWidth = 1 / scale;
                ctx.beginPath(); ctx.arc(bar.position.x, bar.position.y, (bar.dia * 0.5) / scale, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            }
        });
        if (shape.rebar.stirrups) shape.rebar.stirrups.forEach(stirrup => {
            ctx.strokeStyle = '#4682B4'; ctx.lineWidth = (stirrup.dia / 5) / scale;
            ctx.beginPath(); stirrup.points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y)); ctx.closePath(); ctx.stroke();
        });
    }
}
 
         function getAllVisibleShapes() {
             if (!activeDrawingName) return [];
             const activeDrawing = drawings[activeDrawingName];
             let allShapes = [];
             for (const name in activeDrawing.layers) {
                 if (activeDrawing.layers[name].visible) {
                     // Add layer name to each shape for easy reference
                     const shapesWithLayer = activeDrawing.layers[name].shapes.map(s => ({...s, layerName: name}));
                     allShapes = allShapes.concat(shapesWithLayer);
                 }
             }
             return allShapes;
         }
 
         function drawTotalsBox() {
    if (!activeDrawingName) return;
    const activeDrawing = drawings[activeDrawingName];

    let tL=0, tA=0, tV=0, tSA=0, tRL=0, tRW=0, tC=0;
    let combinedRebarDetails = {};
    const allShapes = getAllVisibleShapes();

    allShapes.forEach(s => {
        const m = calculateShapeMetrics(s);
        tL+=m.length * (s.copyCount || 1);
        tA+=m.area * (s.copyCount || 1);
        tV+=m.volume * (s.copyCount || 1);
        tSA+=m.surfaceArea * (s.copyCount || 1);
        tC+=m.count * (s.copyCount || 1);
        tRL+=m.rebarLength * (s.copyCount || 1);
        tRW+=m.rebarWeight * (s.copyCount || 1);
        for (const dia in m.rebarDetailsByDia) {
            if (!combinedRebarDetails[dia]) combinedRebarDetails[dia] = { length: 0, weight: 0 };
            combinedRebarDetails[dia].length += m.rebarDetailsByDia[dia].length * (s.copyCount || 1);
            combinedRebarDetails[dia].weight += m.rebarDetailsByDia[dia].weight * (s.copyCount || 1);
        }
    });

    // --- MODIFICATION START ---
    // Use spans with data attributes to make quantities selectable
    document.getElementById('totalQuantitiesBox').innerHTML = `
        <h3>Element Take-off</h3>
        <p>Total Length: <span class="quantity-value" data-type="Total Element Length" data-unit="m">${tL.toFixed(2)}</span> m</p>
        <p>Total Plan Area: <span class="quantity-value" data-type="Total Plan Area" data-unit="m²">${tA.toFixed(2)}</span> m²</p>
        <p>Total Wall Area: <span class="quantity-value" data-type="Total Wall Area" data-unit="m²">${tSA.toFixed(2)}</span> m²</p>
        <p>Total Volume: <span class="quantity-value" data-type="Total Volume" data-unit="m³">${tV.toFixed(2)}</span> m³</p>
        <p>Total Count: <span class="quantity-value" data-type="Total Count" data-unit="pcs">${tC}</span></p>
        <p>Scale: 1 meter = ${activeDrawing.pixelsPerMeter.toFixed(2)} pixels</p>`;

    let rebarQuantitiesHTML = `
        <h3>Rebar Take-off</h3>
        <p>Total Rebar Length: <span class="quantity-value" data-type="Total Rebar Length" data-unit="m">${tRL.toFixed(2)}</span> m</p>
        <p>Total Rebar Weight: <span class="quantity-value" data-type="Total Rebar Weight" data-unit="kg">${tRW.toFixed(2)}</span> kg</p>`;
    // --- MODIFICATION END ---
    
    const sortedDiameters = Object.keys(combinedRebarDetails).sort((a, b) => parseInt(a) - parseInt(b));
    if (sortedDiameters.length > 0) {
        rebarQuantitiesHTML += '<h4>By Diameter:</h4><ul>';
        sortedDiameters.forEach(dia => {
            // --- MODIFICATION START ---
            rebarQuantitiesHTML += `<li><strong>${dia}mm:</strong> 
                <span class="quantity-value" data-type="Rebar Length (${dia}mm)" data-unit="m">${combinedRebarDetails[dia].length.toFixed(2)}</span> m 
                (<span class="quantity-value" data-type="Rebar Weight (${dia}mm)" data-unit="kg">${combinedRebarDetails[dia].weight.toFixed(2)}</span> kg)
            </li>`;
            // --- MODIFICATION END ---
        });
        rebarQuantitiesHTML += '</ul>';
    } else { rebarQuantitiesHTML += '<p>No rebar quantities to display.</p>'; }
    document.getElementById('rebarQuantitiesBox').innerHTML = rebarQuantitiesHTML;
}
 
// PASTE THIS ENTIRE BLOCK OF CODE right before the calculateShapeMetrics function

/**
 * Calculates the area of a 2D polygon using the shoelace formula.
 * @param {Array<{x: number, y: number}>} points The vertices of the polygon.
 * @returns {number} The area of the polygon.
 */
function calculatePolygonArea(points) {
    let area = 0;
    const n = points.length;
    for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += points[i].x * points[j].y;
        area -= points[j].x * points[i].y;
    }
    return Math.abs(area / 2.0);
}

/**
 * Calculates the perimeter of a 2D polygon.
 * @param {Array<{x: number, y: number}>} points The vertices of the polygon.
 * @returns {number} The perimeter of the polygon.
 */
function calculatePolygonPerimeter(points) {
    let perimeter = 0;
    const n = points.length;
    for (let i = 0; i < n; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % n];
        perimeter += Math.hypot(p2.x - p1.x, p2.y - p1.y);
    }
    return perimeter;
}

/**
 * Calculates the area of a 2D polygon using the shoelace formula.
 * @param {Array<{x: number, y: number}>} points The vertices of the polygon.
 * @returns {number} The area of the polygon.
 */
function calculatePolygonArea(points) {
    let area = 0;
    const n = points.length;
    for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += points[i].x * points[j].y;
        area -= points[j].x * points[i].y;
    }
    return Math.abs(area / 2.0);
}

/**
 * Calculates the perimeter of a 2D polygon.
 * @param {Array<{x: number, y: number}>} points The vertices of the polygon.
 * @returns {number} The perimeter of the polygon.
 */
function calculatePolygonPerimeter(points) {
    let perimeter = 0;
    const n = points.length;
    for (let i = 0; i < n; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % n];
        perimeter += Math.hypot(p2.x - p1.x, p2.y - p1.y);
    }
    return perimeter;
}



// REPLACE THIS ENTIRE FUNCTION
function calculateShapeMetrics(shape) {
    if (!activeDrawingName) return { length: 0, area: 0, volume: 0, surfaceArea: 0, rebarLength: 0, rebarWeight: 0, rebarDetailsByDia: {}, count: 0 };
    const pixelsPerMeter = drawings[activeDrawingName].pixelsPerMeter;

    let pL = 0, pA = 0, rL = 0, rW = 0, count = 0;
    let rebarDetailsByDia = {};

    const addRebarDetail = (dia, length) => {
        if (!dia || !length || length <= 0) return;
        if (!rebarDetailsByDia[dia]) {
            rebarDetailsByDia[dia] = { length: 0, weight: 0 };
        }
        rebarDetailsByDia[dia].length += length;
        const weight = ((dia * dia) / 162) * length;
        rebarDetailsByDia[dia].weight += weight;
    };

    const getCurvePoints = (p0, cp, p1, segments = 20) => {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const x = (1 - t) ** 2 * p0.x + 2 * (1 - t) * t * cp.x + t ** 2 * p1.x;
            const y = (1 - t) ** 2 * p0.y + 2 * (1 - t) * t * cp.y + t ** 2 * p1.y;
            points.push({ x, y });
        }
        return points;
    };
    
    const getCalculationPoints = (pointsArray) => {
        if (!pointsArray || pointsArray.length === 0) return [];
        const calculationPoints = [pointsArray[0]];
        for (let i = 1; i < pointsArray.length; i++) {
            const prevP = pointsArray[i-1];
            const currP = pointsArray[i];
            if (currP.isCurve) {
                const curveSegmentPoints = getCurvePoints(prevP, {x: currP.cpx, y: currP.cpy}, currP);
                calculationPoints.push(...curveSegmentPoints.slice(1));
            } else {
                calculationPoints.push(currP);
            }
        }
        return calculationPoints;
    };

    if (shape.type === 'count') {
        count = shape.points ? shape.points.length : 0;
    } else if (shape.type === 'circle' && shape.radius) {
        pL = 2 * Math.PI * shape.radius;
        pA = Math.PI * (shape.radius ** 2);
    } else if (shape.points && shape.points.length > 1) {
        const mainCalcPoints = getCalculationPoints(shape.points);
        for (let i = 0; i < mainCalcPoints.length - 1; i++) {
            pL += Math.hypot(mainCalcPoints[i+1].x - mainCalcPoints[i].x, mainCalcPoints[i+1].y - mainCalcPoints[i].y);
        }
        if (shape.isClosed && mainCalcPoints.length > 2) {
            pL += Math.hypot(mainCalcPoints[mainCalcPoints.length - 1].x - mainCalcPoints[0].x, mainCalcPoints[0].y);
        }
    }

    if (shape.isClosed && shape.points && shape.points.length >= 2) {
        const calculatePixelArea = (pts) => {
            let a = 0;
            for (let i = 0; i < pts.length; i++) {
                const j = (i + 1) % pts.length;
                a += pts[i].x * pts[j].y - pts[j].x * pts[i].y;
            }
            return Math.abs(a) / 2;
        };
        const mainPts = getCalculationPoints(shape.points);
        pA = calculatePixelArea(mainPts);
        if (shape.holes && Array.isArray(shape.holes)) {
            shape.holes.forEach(holeShape => {
                const holePts = getCalculationPoints(holeShape.points);
                if (holePts.length > 2) { pA -= calculatePixelArea(holePts); }
            });
        }
    }

    const len = pL / pixelsPerMeter;
    const area = pA / (pixelsPerMeter ** 2);
    let vol = 0, surfA = 0;
    
    // --- THIS IS THE NEW CALCULATION LOGIC FOR THE SHELL ---
    if (shape.type === 'shell') {
        if (shape.profilePoints && shape.profilePoints.length > 2) {
            const profileArea = calculatePolygonArea(shape.profilePoints);
            const profilePerimeter = calculatePolygonPerimeter(shape.profilePoints);
            vol = profileArea * len;
            surfA = profilePerimeter * len; 

            // Longitudinal Rebar
            if (shape.profileRebar && shape.profileRebar.length > 0) {
                shape.profileRebar.forEach(bar => {
                    const totalLengthForBar = len;
                    rL += totalLengthForBar;
                    addRebarDetail(bar.dia, totalLengthForBar);
                });
            }
            
            // Stirrups
            if (shape.profileStirrups && shape.profileStirrups.length > 0) {
                shape.profileStirrups.forEach(stirrup => {
                    const stirrupPerimeter = calculatePolygonPerimeter(stirrup.points);
                    const spacingMeters = stirrup.spacing / 1000;
                    if (len > 0 && spacingMeters > 0) {
                        const numStirrups = Math.floor(len / spacingMeters) + 1;
                        const totalStirrupLength = numStirrups * stirrupPerimeter;
                        rL += totalStirrupLength;
                        addRebarDetail(stirrup.dia, totalStirrupLength);
                    }
                });
            }
        }
    } 
    // --- END OF NEW SHELL LOGIC ---
    else if (shape.type === 'variablePolygon') {
        const avgHeight = shape.points.reduce((sum, p) => sum + (p.z || 0), 0) / shape.points.length;
        vol = area * avgHeight;
        surfA = len * avgHeight;
    } else if (shape.type === 'polyline' && shape.polylineType === 'sheet') {
         surfA = len * (shape.height || 0);
         vol = 0;
    } else {
         surfA = len > 0 && shape.height > 0 ? len * shape.height : 0;
         vol = area > 0 && shape.height > 0 ? area * shape.height : 0;
    }

    if (shape.rebar) {
        let totalRebarLength = 0;
        if (shape.rebar.type === 'manual') {
             if (shape.rebar.bars) shape.rebar.bars.forEach(b => {
                 let barLengthMeters = 0;
                 if (b.points && b.points.length > 1) {
                     let barPixelLength = 0;
                     for (let i = 0; i < b.points.length - 1; i++) barPixelLength += Math.hypot(b.points[i+1].x - b.points[i].x, b.points[i+1].y - b.points[i].y);
                     barLengthMeters = barPixelLength / pixelsPerMeter * (b.quantity || 1);
                 } else if (b.height > 0) {
                     barLengthMeters = b.height * (b.quantity || 1);
                 }
                 addRebarDetail(b.dia, barLengthMeters); 
                 totalRebarLength += barLengthMeters;
             });
             if (shape.rebar.stirrups) shape.rebar.stirrups.forEach(s => {
                 let stirrupPerimeterPixels = 0;
                 for (let i = 0; i < s.points.length; i++) stirrupPerimeterPixels += Math.hypot(s.points[(i + 1) % s.points.length].x - s.points[i].x, s.points[(i + 1) % s.points.length].y - s.points[i].y);
                 const stirrupPerimeterMeters = stirrupPerimeterPixels / pixelsPerMeter;
                 let parentLengthMeters = shape.type === 'polyline' ? len : shape.height;
                 const spacingMeters = s.spacing / 1000;
                 if (parentLengthMeters > 0 && spacingMeters > 0) {
                     const numStirrups = Math.floor(parentLengthMeters / spacingMeters) + 1;
                     const totalStirrupLength = numStirrups * stirrupPerimeterMeters;
                     addRebarDetail(s.dia, totalStirrupLength); 
                     totalRebarLength += totalStirrupLength;
                 }
             });
              rL += totalRebarLength;
        } 
        else if (shape.rebar.type === 'pattern') { 
            if (shape.rebar.pattern === 'area') {
                const xCoords = shape.points.map(p => p.x);
                const yCoords = shape.points.map(p => p.y);
                const widthPixels = Math.max(...xCoords) - Math.min(...xCoords);
                const lengthPixels = Math.max(...yCoords) - Math.min(...yCoords);
                const widthMeters = widthPixels / pixelsPerMeter;
                const lengthMeters = lengthPixels / pixelsPerMeter;

                if (shape.rebar.dia1 && shape.rebar.spacing1 > 0) {
                    const spacing1Meters = shape.rebar.spacing1 / 1000;
                    const numBars1 = Math.floor(widthMeters / spacing1Meters) + 1;
                    const totalLength1 = numBars1 * lengthMeters;
                    addRebarDetail(shape.rebar.dia1, totalLength1);
                    totalRebarLength += totalLength1;
                }
                if (shape.rebar.dia2 && shape.rebar.spacing2 > 0) {
                    const spacing2Meters = shape.rebar.spacing2 / 1000;
                    const numBars2 = Math.floor(lengthMeters / spacing2Meters) + 1;
                    const totalLength2 = numBars2 * widthMeters;
                    addRebarDetail(shape.rebar.dia2, totalLength2);
                    totalRebarLength += totalLength2;
                }
            } else if (shape.rebar.pattern === 'line') {
                if (shape.rebar.longBarCount > 0 && shape.rebar.longBarDia) {
                    const totalLongLength = shape.rebar.longBarCount * len;
                    addRebarDetail(shape.rebar.longBarDia, totalLongLength);
                    totalRebarLength += totalLongLength;
                }
                if (shape.rebar.tieDia && shape.rebar.tieSpacing > 0 && shape.height > 0) {
                    const assumedWidth = 0.2;
                    const tiePerimeter = 2 * (shape.height + assumedWidth);
                    const tieSpacingMeters = shape.rebar.tieSpacing / 1000;
                    const numTies = Math.floor(len / tieSpacingMeters) + 1;
                    const totalTieLength = numTies * tiePerimeter;
                    addRebarDetail(shape.rebar.tieDia, totalTieLength);
                    totalRebarLength += totalTieLength;
                }
            }
            rL += totalRebarLength;
        }
         
        let totalRebarWeight = 0;
        for (const dia in rebarDetailsByDia) {
            totalRebarWeight += rebarDetailsByDia[dia].weight;
        }
        rW = totalRebarWeight;
    }

    return { length: len, area: area, volume: vol, surfaceArea: surfA, rebarLength: rL, rebarWeight: rW, rebarDetailsByDia: rebarDetailsByDia, count: count };
}

function addRebarDetail(dia, length, rebarDetailsByDia) {
    if (!rebarDetailsByDia[dia]) {
        rebarDetailsByDia[dia] = { length: 0, weight: 0 };
    }
    rebarDetailsByDia[dia].length += length;
    const weight = ((dia * dia) / 162) * length;
    rebarDetailsByDia[dia].weight += weight;
};

// ADD THESE TWO HELPER FUNCTIONS

/**
 * Calculates the area of a 2D polygon using the shoelace formula.
 * @param {Array<{x: number, y: number}>} points The vertices of the polygon.
 * @returns {number} The area of the polygon.
 */
function calculatePolygonArea(points) {
    let area = 0;
    const n = points.length;
    for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        area += points[i].x * points[j].y;
        area -= points[j].x * points[i].y;
    }
    return Math.abs(area / 2.0);
}

/**
 * Calculates the perimeter of a 2D polygon.
 * @param {Array<{x: number, y: number}>} points The vertices of the polygon.
 * @returns {number} The perimeter of the polygon.
 */
function calculatePolygonPerimeter(points) {
    let perimeter = 0;
    const n = points.length;
    for (let i = 0; i < n; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % n];
        perimeter += Math.hypot(p2.x - p1.x, p2.y - p1.y);
    }
    return perimeter;
}



         
         // --- Eraser Logic ---
         function eraseAtPoint(imgX, imgY) {
             if (!activeDrawingName) return;
             const activeDrawing = drawings[activeDrawingName];
             let deleted = false;
             for (const name in activeDrawing.layers) {
                 if (activeDrawing.layers[name].visible) {
                     for (let i = activeDrawing.layers[name].shapes.length - 1; i >= 0; i--) {
                         const shape = activeDrawing.layers[name].shapes[i];
                         if (isPointOnShape(imgX, imgY, shape)) {
                              if (scene && shape._3DObject) scene.remove(shape._3DObject);
                             activeDrawing.layers[name].shapes.splice(i, 1);
                             deleted = true;
                             break;
                         }
                     }
                 }
                 if (deleted) break;
             }
             if (deleted) {
                 draw();
                 drawTotalsBox();
             }
         }
 
         function isPointOnShape(x, y, shape) {
             if (!activeDrawingName) return false;
             const scale = drawings[activeDrawingName].scale;
             const hitRadius = (ERASER_RADIUS / scale);
             switch (shape.type) {
                 case 'variablePolygon': // <-- ADD THIS LINE
                 case 'shell':           // <-- ALSO ADD 'shell' for good measure
                 case 'polygon':
                 case 'polyline':
                 case 'freehand':
                     if (shape.points.length > 1) {
                          for (let i = 0; i < shape.points.length; i++) {
                             const p1 = shape.points[i];
                             const p2 = shape.points[(i + 1) % shape.points.length];
                             if (!shape.isClosed && i === shape.points.length -1) continue;
                             if (distToSegment({x,y}, p1, p2) < hitRadius) return true;
                         }
                     }
                     return false;
                 case 'circle':
                     if (shape.center && shape.radius) {
                         return Math.abs(Math.hypot(x - shape.center.x, y - shape.center.y) - shape.radius) < hitRadius;
                     }
                     return false;
                 case 'count':
                     if (shape.points) {
                         for(const p of shape.points) {
                            if (Math.hypot(x - p.x, y - p.y) < hitRadius) return true;
                         }
                     }
                     return false;
             }
             return false;
         }
 
         function distToSegment(p, v, w) {
           const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
           if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
           let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
           t = Math.max(0, Math.min(1, t));
           return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
         }
 
 
         // --- Event Handlers ---
         function onMouseDown(e) {
             e.preventDefault();
             if (!activeDrawingName) return;
             lastX = e.clientX;
             lastY = e.clientY;
             const shapeType = document.getElementById('shapeType').value;
 
             if (e.button === 1) { // Middle mouse button
                 isPanning = true;
             } else if (e.button === 0) { // Left mouse button
                 mouseDown = true;
                 const { originX, originY, scale } = drawings[activeDrawingName];
                 const r = canvas.getBoundingClientRect();
                 const iX = (e.clientX - r.left - originX) / scale;
                 const iY = (e.clientY - r.top - originY) / scale;
 
                 if (shapeType === 'eraser') {
                     isErasing = true;
                     eraseAtPoint(iX, iY);
                 } else if (!rebarMode.active && !copyMoveMode.active && shapeType === 'freehand') {
                     isDrawingFreehand = true;
                     resetCurrentShape();
                     currentShape.points.push({ x: iX, y: iY });
                 }
             }
         }
 
         async function onMouseUp(e) {
             e.preventDefault();
             if (!activeDrawingName) return;
             if (e.button === 1) { isPanning = false; }
             else if (e.button === 0) {
                 if (isErasing) isErasing = false;
                 if (isDrawingFreehand) {
                     isDrawingFreehand = false;
                     if (currentShape.points.length > 2) {
                         currentShape.type = 'polygon';
                         currentShape.isClosed = true;
                         await finalizeShape();
                     } else {
                         resetCurrentShape();
                     }
                 }
                 mouseDown = false;
             }
         }
 
        // REPLACE THIS ENTIRE FUNCTION
        function onMouseMove(e) {
    if (!activeDrawingName) return;
    const activeDrawing = drawings[activeDrawingName];
    const r = canvas.getBoundingClientRect();
    const sX = e.clientX - r.left;
    const sY = e.clientY - r.top;
    const iX = (sX - activeDrawing.originX) / activeDrawing.scale;
    const iY = (sY - activeDrawing.originY) / activeDrawing.scale;


    if (isPanning) {
        activeDrawing.originX += e.clientX - lastX;
        activeDrawing.originY += e.clientY - lastY;
    } else if (copyMoveMode.active && copyMoveMode.shape) {
        const dx = iX - copyMoveMode.grabPoint.x;
        const dy = iY - copyMoveMode.grabPoint.y;

        if (copyMoveMode.shape.points) {
            for (let i = 0; i < copyMoveMode.shape.points.length; i++) {
                copyMoveMode.shape.points[i].x += dx;
                copyMoveMode.shape.points[i].y += dy;
            }
        }
        if (copyMoveMode.shape.center) {
            copyMoveMode.shape.center.x += dx;
            copyMoveMode.shape.center.y += dy;
        }
        copyMoveMode.grabPoint = { x: iX, y: iY };
        angleIndicator.style.visibility = 'hidden';
    } else if (isErasing) {
        eraseAtPoint(iX, iY);
    } else if (isDrawingFreehand) {
        currentShape.points.push({ x: iX, y: iY });
        angleIndicator.style.visibility = 'hidden';
    // --- MODIFICATION START: Live Circle Drawing ---
    } else if (currentShape.type === 'circle' && currentShape.points.length === 1) {
        currentShape.center = currentShape.points[0];
        currentShape.radius = Math.hypot(iX - currentShape.center.x, iY - currentShape.center.y);
        angleIndicator.style.visibility = 'hidden'; // Hide angle indicator during circle draw
    // --- MODIFICATION END ---
    } else {
        let lastPoint = null;
        if (rebarMode.active && rebarMode.drawingMode === 'planar' && currentRebarLine.points.length > 0) {
            lastPoint = currentRebarLine.points[currentRebarLine.points.length - 1];
        } else if (rebarMode.active && rebarMode.drawingMode === 'stirrup' && currentStirrupShape.points.length > 0) {
            lastPoint = currentStirrupShape.points[currentStirrupShape.points.length - 1];
        } else if (!rebarMode.active) { 
            const shapeType = currentShape.type;
            if ((shapeType === 'polyline' || shapeType === 'polygon' || shapeType === 'variablePolygon') && currentShape.points.length > 0) {
                lastPoint = currentShape.points[currentShape.points.length - 1];
            }
        }

        if (lastPoint) {
            const dx = iX - lastPoint.x;
            const dy = iY - lastPoint.y;
            const pixelDist = Math.hypot(dx, dy);
            const realDist = pixelDist / activeDrawing.pixelsPerMeter;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            angleIndicator.innerHTML = `Dist: ${realDist.toFixed(2)} m | Angle: ${angle.toFixed(1)}°`;
            angleIndicator.style.left = e.clientX + 20 + 'px';
            angleIndicator.style.top = e.clientY + 20 + 'px';
            angleIndicator.style.visibility = 'visible';
        } else {
            angleIndicator.style.visibility = 'hidden';
        }
    }

    lastX = e.clientX;
    lastY = e.clientY;
    draw(sX, sY);
}
 
         function onWheel(e) { 
             e.preventDefault(); 
             if (!activeDrawingName) return;
             const activeDrawing = drawings[activeDrawingName];
             const r=canvas.getBoundingClientRect();
             const mX=e.clientX-r.left,mY=e.clientY-r.top;
             const iX=(mX-activeDrawing.originX)/activeDrawing.scale;
             const iY=(mY-activeDrawing.originY)/activeDrawing.scale;
             const z=e.deltaY<0?1.1:0.9;
             const nS=Math.max(0.1,Math.min(10,activeDrawing.scale*z));
             activeDrawing.originX-=iX*(nS-activeDrawing.scale);
             activeDrawing.originY-=iY*(nS-activeDrawing.scale);
             activeDrawing.scale=nS;
             draw(); 
         }
         
         // Estimator8.0.html

// Estimator8.0.html

// REPLACE THIS ENTIRE FUNCTION

async function onClick(e) {
    if (!activeDrawingName || isPanning || isErasing || (e.button !== 0)) return;
    if (document.getElementById('shapeType').value === 'freehand' || e.detail > 1) return;

    const activeDrawing = drawings[activeDrawingName];
    const { originX, originY, scale } = activeDrawing;
    const r = canvas.getBoundingClientRect(), iX = (e.clientX - r.left - originX) / scale, iY = (e.clientY - r.top - originY) / scale;

    if (scaleMode) {
        scalePoints.push({x:iX,y:iY});
        if (scalePoints.length === 2) {
            scaleMode=false;
            const pD=Math.hypot(scalePoints[1].x-scalePoints[0].x,scalePoints[1].y-scalePoints[0].y);
            if (pD > 0.1) {
                const rD = parseFloat(await customPrompt("Set Scale", "Enter real distance (m):", "1.0"));
                if (rD > 0) activeDrawing.pixelsPerMeter = pD / rD;
            }
            draw();
            drawTotalsBox();
        }
        return;
    }

    if (copyMoveMode.active) {
        if (!copyMoveMode.shape) {
            for (const name in activeDrawing.layers) {
                if (activeDrawing.layers[name].visible) {
                    for (let i = activeDrawing.layers[name].shapes.length - 1; i >= 0; i--) {
                        const shape = activeDrawing.layers[name].shapes[i];
                        if (isPointOnShape(iX, iY, shape)) {
                            copyMoveMode.shape = JSON.parse(JSON.stringify(shape));
                            delete copyMoveMode.shape._3DObject;
                            copyMoveMode.grabPoint = { x: iX, y: iY };
                            document.getElementById('copyMoveBtn').style.backgroundColor = '#4CAF50';
                            customAlert('Shape copied. Move the mouse to position it and click to place.');
                            return;
                        }
                    }
                }
            }
        } else {
            const newShape = copyMoveMode.shape;
            const newElevationStr = await customPrompt("Set Duplicate's Elevation", "Enter the base elevation (m) for this duplicate:", newShape.baseElevation || "0.0");
            if (newElevationStr === null) {
                copyMoveMode.shape = null;
                copyMoveMode.grabPoint = null;
                document.getElementById('copyMoveBtn').style.backgroundColor = '#ff9800';
                draw();
                return;
            }
            newShape.baseElevation = parseFloat(newElevationStr) || 0;

            const currentLayerName = activeDrawing.currentLayerName;
            activeDrawing.layers[currentLayerName].shapes.push(newShape);
            if (is3DMode) addShapeTo3DScene(newShape, activeDrawing.layers[currentLayerName].shapes.length - 1);
            drawTotalsBox();

            copyMoveMode.shape = null;
            copyMoveMode.grabPoint = null;
            document.getElementById('copyMoveBtn').style.backgroundColor = '#ff9800';
            customAlert('Shape placed. Click another shape to copy it, or deactivate "Copy & Move" mode.');
        }
        return;
    }

    if (rebarMode.active) {
        if (rebarMode.drawingMode === 'planar') { currentRebarLine.points.push({ x: iX, y: iY }); }
        else if (rebarMode.drawingMode === 'vertical') {
            const barHeight = parseFloat(await customPrompt("Specify Rebar Height", "Enter height/length for this vertical bar (m):", "3.0"));
            if (barHeight > 0) {
                const numBars = parseInt(await customPrompt("Number of Bars", "How many vertical bars at this location?", "1")) || 1;
                rebarMode.parentShape.rebar.bars.push({ position: {x: iX, y: iY}, dia: parseFloat(document.getElementById('rebarDiaSelect').value), height: barHeight, quantity: numBars });
                drawTotalsBox();
            }
        } else if (rebarMode.drawingMode === 'stirrup') {
            const p = currentStirrupShape.points;
            p.push({ x: iX, y: iY });
            if (p.length > 2 && Math.hypot(p[0].x - iX, p[0].y - iY) < LOOP_THRESHOLD/scale) {
                p.pop(); currentStirrupShape.isClosed = true; await finalizeStirrupShape();
            }
        }
    } else {
        const shapeType = document.getElementById('shapeType').value;
        
        // --- MODIFICATION: Added 'shell' to this condition ---
        if (isCurveMode && (shapeType === 'polygon' || shapeType === 'polyline' || shapeType === 'shell')) {
            if (currentShape.points.length === 0) {
                currentShape.points.push({ x: iX, y: iY, isCurve: false });
            } else if (!tempControlPoint) {
                tempControlPoint = { x: iX, y: iY };
                customAlert('Control point set. Now click the curve\'s end point.');
            } else {
                currentShape.points.push({ x: iX, y: iY, isCurve: true, cpx: tempControlPoint.x, cpy: tempControlPoint.y });
                tempControlPoint = null;
                toggleCurveMode(false); 
                
                const p = currentShape.points;
                if ((shapeType === 'polygon' || shapeType === 'shell') && p.length > 2 && Math.hypot(p[0].x - iX, p[0].y - iY) < LOOP_THRESHOLD/scale) {
                    p.pop();
                    currentShape.isClosed = true;
                    await finalizeShape();
                }
            }
        } else {
            if (shapeType === 'count') {
                currentShape.points.push({ x: iX, y: iY });
            } else if (shapeType !== 'eraser') {
                currentShape.points.push({ x: iX, y: iY, isCurve: false });
                
                if (currentShape.type === 'polygon' || currentShape.type === 'variablePolygon'|| currentShape.type === 'shell') {
                    const p = currentShape.points;
                    if (p.length > 2 && Math.hypot(p[0].x - iX, p[0].y - iY) < LOOP_THRESHOLD/scale) {
                        p.pop();
                        currentShape.isClosed = true;
                        await finalizeShape();
                    }
                } else if (currentShape.type === 'circle') {
                    if (currentShape.points.length === 2) {
                        currentShape.center = currentShape.points[0];
                        currentShape.radius = Math.hypot(currentShape.points[1].x - currentShape.center.x, currentShape.points[1].y - currentShape.center.y);
                        await finalizeShape();
                    }
                }
            }
        }
    }
    draw(e.clientX - r.left, e.clientY - r.top);
}


async function onKeyDown(e) {
    if (e.key === 'Enter') {
        if (rebarMode.active) {
            if (rebarMode.drawingMode === 'planar' && currentRebarLine.points.length >= 2) await finalizeRebarLine();
            else if (rebarMode.drawingMode === 'stirrup' && currentStirrupShape.points.length >= 3) { currentStirrupShape.isClosed = true; await finalizeStirrupShape(); }
        } else {
            if (currentShape.type === 'count' && currentShape.points.length > 0) {
                await finalizeShape();
            } else if (currentShape.type === 'polyline' && currentShape.points.length >= 2) {
                await finalizeShape();
            // --- MODIFIED CONDITION TO INCLUDE variablePolygon ---
            } else if ((currentShape.type === 'polygon' || currentShape.type === 'variablePolygon' || currentShape.type === 'shell') && currentShape.points.length >= 3) {
                currentShape.isClosed = true;
                await finalizeShape();
            }
        }
    } else if (e.key === 'Escape') {
        if (copyMoveMode.active) { exitCopyMoveMode(); }
        else if (rebarMode.active) { exitRebarMode(true); }
        else { resetCurrentShape(); scaleMode = false; }
    } else if (e.key.toLowerCase() === 'c') {
        if (!e.ctrlKey && !e.metaKey && (currentShape.type === 'polygon' || currentShape.type === 'polyline')) {
            toggleCurveMode();
        }
    }
    draw();
}
 
         // --- Core Application Logic ---
         // Estimator8.0.html

// REPLACE THIS ENTIRE FUNCTION
// REPLACE THIS ENTIRE FUNCTION
async function finalizeShape() {
    if (isDeducting) {
        if ((currentShape.points.length < 3 && currentShape.type !== 'circle') || currentShape.type === 'count') {
             resetCurrentShape();
             draw();
             return;
        }
        const metrics = calculateShapeMetrics(currentShape);
        const quantity = metrics.surfaceArea > 0 ? metrics.surfaceArea : metrics.area;
        const unit = metrics.surfaceArea > 0 ? 'm²' : 'm²';
        if (deductor.stage === 'primary') {
            if (quantity <= 0) {
                customAlert("Primary element has no area. Please draw a valid shape.");
                resetCurrentShape(); draw(); return;
            }
            deductor.primaryShape = { ...currentShape };
            document.getElementById('deductorPrimary').textContent = quantity.toFixed(2);
            document.getElementById('deductorUnit').textContent = unit;
            deductor.tempShapes.push({...currentShape, color: '#66BB6A'});
            deductor.stage = 'deducting';
            customAlert(`Primary area set. Now, draw the first opening to subtract. Press "Enter" to finalize it.`);
        } else {
            deductor.deductionShapes.push({ ...currentShape });
            let currentDeductionsSum = 0;
            deductor.deductionShapes.forEach(shape => {
                const shapeMetrics = calculateShapeMetrics(shape);
                currentDeductionsSum += shapeMetrics.surfaceArea > 0 ? shapeMetrics.surfaceArea : shapeMetrics.area;
            });
            document.getElementById('deductorSum').textContent = currentDeductionsSum.toFixed(2);
            deductor.tempShapes.push({...currentShape, color: '#f44336'});
            customAlert(`Deducted ${quantity.toFixed(2)} ${unit}. Draw another opening or click "Apply" to finalize the element.`);
        }
        resetCurrentShape();
        draw();
        return;
    }

    angleIndicator.style.visibility = 'hidden';
    if (!activeDrawingName) return;
    const activeDrawing = drawings[activeDrawingName];

    if ((currentShape.points.length < 1 && !currentShape.center) || currentShape.type === 'eraser') {
        resetCurrentShape();
        return;
    }

    const defaultName = currentShape.type === 'count' ? "Countable Item" : (currentShape.type === 'polyline' ? "Wall" : "Slab");
    const nI = await customPrompt("Element Properties", "Enter Element Name:", defaultName);
    if (!nI) { resetCurrentShape(); draw(); return; }
    
    const desc = await showDescriptionBuilder();
    
    let newShape = {
        ...currentShape,
        name: nI,
        color: getElementColor(nI),
        description: desc || '',
        copyCount: 1,
    };

    if (currentShape.type === 'count') {
        const el = await customPrompt("Element Properties", "Enter Elevation (m) for these items:", "0.0");
        if (el === null) { resetCurrentShape(); draw(); return; }
        newShape.baseElevation = parseFloat(el) || 0;
    } else if (currentShape.type === 'polyline') {
        const polylineChoice = await choicePrompt("Polyline Type", "Choose the type of element to create:", [
            { id: 'sheet', text: 'Vertical Wall (Sheet)' },
            { id: 'pipe', text: 'Sloped Pipe' }
        ]);
        if (!polylineChoice) { resetCurrentShape(); draw(); return; }
        newShape.polylineType = polylineChoice;
        if (polylineChoice === 'sheet') {
            const el = await customPrompt("Wall Properties", "Enter Base Elevation (m):", "0.0");
            if (el === null) { resetCurrentShape(); draw(); return; }
            newShape.baseElevation = parseFloat(el) || 0;
            
            newShape.height = parseFloat(document.getElementById('rulerValueInput').value) / 1000; // convert mm to m
            if (isNaN(newShape.height)) { newShape.height = 0; }

        } else if (polylineChoice === 'pipe') {
            const diaI = await customPrompt("Pipe Properties", "Enter pipe diameter (m):", "0.3");
            if (diaI === null) { resetCurrentShape(); draw(); return; }
            newShape.diameter = parseFloat(diaI);
            for (let i = 0; i < newShape.points.length; i++) {
                const elevationStr = await customPrompt(`Pipe Elevation`, `Enter elevation (m) for point ${i + 1}/${newShape.points.length}:`, "0.0");
                if (elevationStr === null) { resetCurrentShape(); draw(); return; }
                newShape.points[i].z = parseFloat(elevationStr) || 0;
            }
        }
    } else if (currentShape.type === 'variablePolygon') { 
        if (newShape.points.length < 3) { resetCurrentShape(); draw(); return; }
        newShape.isClosed = true;
        const el = await customPrompt("Element Properties", "Enter Base Elevation (m):", "0.0");
        if (el === null) { resetCurrentShape(); draw(); return; }
        newShape.baseElevation = parseFloat(el) || 0;

        for (let i = 0; i < newShape.points.length; i++) {
            const thicknessStr = await customPrompt(`Set Thickness`, `Enter thickness (m) for point ${i + 1}/${newShape.points.length}:`, "0.2");
            if (thicknessStr === null) { resetCurrentShape(); draw(); return; }
            newShape.points[i].z = parseFloat(thicknessStr) || 0;
        }
        newShape.height = null;
    } 
    // --- THIS IS THE NEW LOGIC FOR THE SHELL ---
    else if (currentShape.type === 'shell') {
        if (newShape.points.length < 2) { 
            customAlert("Shell path requires at least 2 points.");
            resetCurrentShape(); 
            draw(); 
            return; 
        }
        // Call the profile designer to get the cross-section
        const designData = await showProfileDesigner();
        if (designData === null) { // User cancelled the designer
            resetCurrentShape(); 
            draw(); 
            return;
        }
        // Assign the returned profile, rebar, and stirrup data to the shape
        newShape.profilePoints = designData.profile;
        newShape.profileRebar = designData.rebar;
        newShape.profileStirrups = designData.stirrups; 

        const el = await customPrompt("Element Properties", "Enter Base Elevation of Path (m):", "0.0");
        if (el === null) { resetCurrentShape(); draw(); return; }
        newShape.baseElevation = parseFloat(el) || 0;
    } 
    
    // --- END OF NEW SHELL LOGIC ---
    else { 
        const el = await customPrompt("Element Properties", "Enter Base Elevation (m):", "0.0");
        if (el === null) { resetCurrentShape(); draw(); return; }
        newShape.baseElevation = parseFloat(el) || 0;
        newShape.height = parseFloat(document.getElementById('rulerValueInput').value) / 1000;
        if (isNaN(newShape.height)) { newShape.height = 0; }
    }
    
    let rebarChoice = 'skip';
    if (newShape.type === 'polygon' || newShape.type === 'polyline' || newShape.type === 'circle' || newShape.type === 'variablePolygon') {
        rebarChoice = await choicePrompt("Rebar Design", "Choose a method to add reinforcement.", [
            { id: 'manual', text: 'Manual Design (Draw)' }, { id: 'pattern', text: 'Pattern Generator' }, { id: 'skip', text: 'Skip Rebar', color: '#777' }
        ]);
    }
    
    newShape.rebar = { type: 'manual', bars: [], stirrups: [] };
    if (rebarChoice === 'pattern') newShape.rebar = await promptForRebarPattern(newShape.type);
    
    const currentLayerName = activeDrawing.currentLayerName;
    activeDrawing.layers[currentLayerName].shapes.push(newShape);
    
    if (is3DMode) {
         renderAllShapesIn3D();
    }
    
    resetCurrentShape();

    if (desc && desc.trim() !== '') {
        const boqChoice = await choicePrompt("Update BOQ", "Do you want to add the generated description to the BOQ now?", [
            {id: 'yes', text: 'Yes, Add to BOQ', color: '#4CAF50'}, {id: 'no', text: 'Not Now', color: '#777'}
        ]);
        if (boqChoice === 'yes') {
            await addDescriptionToBoq(desc);
        }
    }

    if (rebarChoice === 'manual') enterRebarMode(newShape);
    else drawTotalsBox();
    draw();
}

         
         async function finalizeRebarLine() {
             const numBars = parseInt(await customPrompt("Number of Bars", "Enter the total number of identical bars for this line:", "1")) || 1;
             if (numBars > 0) {
                 const finalRebarLine = { ...currentRebarLine, quantity: numBars };
                 rebarMode.parentShape.rebar.bars.push(finalRebarLine);
             }
             resetCurrentRebarLine();
             drawTotalsBox();
         }
         
         async function finalizeStirrupShape() {
             const stirrupDia = parseFloat(await customPrompt("Stirrup Diameter", "Enter stirrup diameter (mm):", document.getElementById('rebarDiaSelect').value));
             const stirrupSpacing = parseFloat(await customPrompt("Stirrup Spacing", "Enter stirrup spacing (mm):", "200"));
             if (stirrupDia > 0 && stirrupSpacing > 0) {
                 const finalStirrup = { ...currentStirrupShape, dia: stirrupDia, spacing: stirrupSpacing };
                 rebarMode.parentShape.rebar.stirrups.push(finalStirrup);
             }
             resetCurrentStirrupShape();
             drawTotalsBox();
         }
 
         function switchRebarDrawingMode(newMode) {
             rebarMode.drawingMode = newMode;
             document.getElementById('rebarDiaSelect').style.display = newMode !== 'stirrup' ? 'inline-block' : 'none';
             document.querySelector('label[for="rebarDiaSelect"]').style.display = newMode !== 'stirrup' ? 'inline-block' : 'none';
             resetCurrentRebarLine();
             resetCurrentStirrupShape();
             updateRebarInstructions();
             draw();
         }
         
         function updateRebarInstructions() {
             const instructions = document.getElementById('rebarModeInstructions');
             switch(rebarMode.drawingMode) {
                 case 'planar': instructions.textContent = "Draw rebar lines. Press 'Enter' to finish a bar."; break;
                 case 'vertical': instructions.textContent = "Click to place a vertical bar."; break;
                 case 'stirrup': instructions.textContent = "Draw a closed stirrup shape. Press 'Enter' to finish."; break;
                 default: instructions.textContent = "";
             }
         }
 
         async function enterRebarMode(pS) {
             rebarMode = { active: true, parentShape: pS, drawingMode: 'planar' };
             if (!pS.rebar) pS.rebar = { type: 'manual', bars: [], stirrups: [] };
             else if (pS.rebar.type !== 'manual') pS.rebar = { type: 'manual', bars: [], stirrups: [] };
             
             document.getElementById('mainActions').style.display='none';
             document.getElementById('viewAndQuantify').style.display='none';
             document.getElementById('rebarControls').style.display='flex';
             document.getElementById('drawingControls').style.display='none';
             document.getElementById('layerControls').style.display='none';
             document.getElementById('rebarDrawModeSelect').value = 'planar';
             switchRebarDrawingMode('planar');
             draw();
         }
         
    // REPLACE THIS ENTIRE FUNCTION
async function exitRebarMode(promptForCount) {
    const parentElement = rebarMode.parentShape; // Store shape before it's cleared

    if (promptForCount && parentElement) {
        const countStr = await customPrompt("Quantification", "Enter the total number of identical structural elements with this rebar design:", parentElement.copyCount || 1);
        parentElement.copyCount = parseInt(countStr) || 1;
    }

    // Check if any rebar was actually drawn before proceeding
    const rebarWasAdded = parentElement && parentElement.rebar && (parentElement.rebar.bars.length > 0 || parentElement.rebar.stirrups.length > 0);

    // Reset the UI and mode state first
    rebarMode.active = false;
    rebarMode.parentShape = null;
    document.getElementById('mainActions').style.display = 'flex';
    document.getElementById('viewAndQuantify').style.display = 'flex';
    document.getElementById('rebarControls').style.display = 'none';
    document.getElementById('drawingControls').style.display = 'flex';
    document.getElementById('layerControls').style.display = 'flex';
    draw();
    drawTotalsBox();

    // --- NEW: BOQ workflow for rebar ---
    if (rebarWasAdded) {
        const statusText = document.getElementById('smmDbStatus').textContent;
        if (!statusText.startsWith('Connected')) {
            customAlert("Rebar design finished. Load a database to add its description and rate to the BOQ.");
            return; // Exit if no DB is loaded
        }
        
        const addToBoq = await choicePrompt(
            "Rebar BOQ Entry",
            `Add rebar details for "${parentElement.name}" to the BOQ?`,
            [{ id: 'yes', text: 'Yes, Add to BOQ', color: '#4CAF50' }, { id: 'no', text: 'No, Thanks', color: '#777' }]
        );

        if (addToBoq === 'yes') {
            // 1. Prompt for description
            const rebarDesc = await showDescriptionBuilder();
            const finalDesc = (rebarDesc && rebarDesc.trim()) ? rebarDesc : `Steel reinforcement for ${parentElement.name}`;

            // 2. Add the description to a new row in the BOQ
            addBoqRow(); // Adds a blank row at the end
            const boqTableBody = document.getElementById('boqTableBody');
            const newRow = boqTableBody.lastChild;
            newRow.children[0].textContent = finalDesc;

            // 3. Prompt for the rate
            document.getElementById('boqModal').style.display = 'flex'; // Show BOQ for context
            const rate = await showRateBuilder(finalDesc);
            if (rate !== null) {
                newRow.children[3].textContent = rate.toFixed(2);
            }
            
            // 4. Set the unit (rebar is typically measured by weight)
            newRow.children[2].textContent = 'kg';

            // 5. Activate the new quantity cell so the user can easily populate it
            const qtyCell = newRow.children[1];
            if (activeBoqCell) activeBoqCell.classList.remove('boq-cell-active');
            activeBoqCell = qtyCell;
            activeBoqCell.classList.add('boq-cell-active');
            
            await customAlert(`The BOQ is ready for the rebar quantity. Click the rebar weight (kg) from the "Rebar Take-off" box to add it.`);
        }
    }
}
         
    function addRulerMarker(shape) {
    if (!is3DMode || !shape.height || shape.height <= 0) return;

    const ruler = document.getElementById('verticalRuler');
    const topLevel = shape.baseElevation + shape.height;

    // This mapping assumes a max visible height of 50m for positioning the marker.
    // You can adjust maxRulerHeight based on the typical scale of your projects.
    const maxRulerHeight = 50; 
    const percentageTop = 100 - Math.min(100, (topLevel / maxRulerHeight * 100));

    if (percentageTop < 0) return; // Don't draw markers outside the view

    const marker = document.createElement('div');
    marker.className = 'ruler-marker';
    marker.style.top = `${percentageTop}%`;
    marker.dataset.level = `${topLevel.toFixed(2)}m`; // Add level text via CSS pseudo-element

    ruler.appendChild(marker);

    // Add tooltip using Tippy.js (already included in your file)
    tippy(marker, {
        content: `<strong>${shape.name}</strong><br>Top Level: ${topLevel.toFixed(2)}m`,
        allowHTML: true,
        placement: 'left',
        theme: 'translucent',
    });
}

         // --- 3D Functions ---
         function toggle3DView() { 
    is3DMode = !is3DMode; 
    document.getElementById('elementInfoBox').style.display = is3DMode ? 'block' : 'none'; 
    
    // *** MODIFICATION: Show/hide the vertical ruler with the 3D view ***
    document.getElementById('verticalRuler').style.display = is3DMode ? 'block' : 'none'; 
    // *** END OF MODIFICATION ***

    threeDContainer.style.visibility = is3DMode ? 'visible' : 'hidden'; 
    if (is3DMode) { 
        initialize3DScene(); 
        renderAllShapesIn3D(); 
        animate3D(); 
    } else { 
        if (animationFrameId) cancelAnimationFrame(animationFrameId); 
        tooltip.style.visibility = 'hidden'; 
    } 
}

    // REPLACE THE ENTIRE initialize3DScene FUNCTION
function initialize3DScene() { 
    if (scene) return; 
    if (!activeDrawingName) return; 
    
    const activeDrawing = drawings[activeDrawingName]; 
    scene = new THREE.Scene(); 
    scene.background=new THREE.Color(0x282828); 
    camera=new THREE.PerspectiveCamera(75, threeDContainer.clientWidth/threeDContainer.clientHeight, 0.1, 5000); 
    const vS=Math.max(canvas.width,canvas.height)/activeDrawing.pixelsPerMeter/activeDrawing.scale*1.2; 
    camera.position.set(vS*0.3,-vS*0.7,vS*0.8); 
    camera.lookAt(0,0,0); 
    renderer=new THREE.WebGLRenderer({antialias:true}); 
    renderer.setSize(threeDContainer.clientWidth,threeDContainer.clientHeight); 
    threeDContainer.appendChild(renderer.domElement); 
    scene.add(new THREE.AmbientLight(0xcccccc,0.8)); 
    const dL=new THREE.DirectionalLight(0xffffff,0.7); 
    dL.position.set(0.5,-1,1).normalize(); 
    scene.add(dL); 
    controls=new THREE.OrbitControls(camera,renderer.domElement); 
    controls.enableDamping=true; 
    const gH=new THREE.GridHelper(100,100,0x0055ff,0x808080); 
    gH.rotation.x=Math.PI/2; 
    scene.add(gH); 

    // --- MODIFICATION: Bipolar Vertical Scale ---
    const scaleHeight = 50; // meters (will go from -50m to +50m)
    const scaleGroup = new THREE.Group();
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    
    // Main vertical line now spans the full range
    const linePoints = [new THREE.Vector3(0, 0, -scaleHeight), new THREE.Vector3(0, 0, scaleHeight)];
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
    const scaleLine = new THREE.Line(lineGeometry, lineMaterial);
    scaleGroup.add(scaleLine);

    // Loop from negative to positive to add ticks and labels
    for (let i = -scaleHeight; i <= scaleHeight; i += 5) {
        const tickPoints = [new THREE.Vector3(0, 0, i), new THREE.Vector3(1, 0, i)];
        const tickGeometry = new THREE.BufferGeometry().setFromPoints(tickPoints);
        const tick = new THREE.Line(tickGeometry, lineMaterial);
        scaleGroup.add(tick);

        const textCanvas = document.createElement('canvas');
        const context = textCanvas.getContext('2d');
        context.font = "Bold 20px Arial";
        context.fillStyle = "rgba(255,255,255,0.95)";
        context.fillText(i + 'm', 0, 20);
        const texture = new THREE.CanvasTexture(textCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(2, 1, 1.0);
        sprite.position.set(2.5, 0, i);
        scaleGroup.add(sprite);
    }
    
    scaleGroup.position.set(-55, -50, 0); 
    scene.add(scaleGroup);
    
    // --- ADDITION: Create persistent lines for hover effect ---
    const indicatorMaterial = new THREE.LineDashedMaterial({ color: 0xffd700, dashSize: 0.5, gapSize: 0.25 });
    const indicatorPoints = [new THREE.Vector3(0,0,0), new THREE.Vector3(1,1,1)];
    
    baseElevationLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(indicatorPoints), indicatorMaterial);
    topElevationLine = new THREE.Line(new THREE.BufferGeometry().setFromPoints(indicatorPoints), indicatorMaterial);
    
    baseElevationLine.computeLineDistances();
    topElevationLine.computeLineDistances();
    
    baseElevationLine.visible = false;
    topElevationLine.visible = false;
    scene.add(baseElevationLine);
    scene.add(topElevationLine);
    // --- END ADDITION ---

    raycaster = new THREE.Raycaster(); 
    threeDContainer.addEventListener('mousemove', onThreeDMouseMove); 
}

         function onThreeDMouseMove(event) {
             event.preventDefault();
             const rect = renderer.domElement.getBoundingClientRect();
             mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
             mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
             tooltip.style.left = event.clientX + 15 + 'px';
             tooltip.style.top = event.clientY + 15 + 'px';
         }
         
         // REPLACE THE ENTIRE checkIntersections FUNCTION
function checkIntersections() {
    if (!scene || !raycaster) return;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);
    const allShapes = getAllVisibleShapes();
    
    // Default: Hide indicator lines if nothing is hovered
    baseElevationLine.visible = false;
    topElevationLine.visible = false;

    if (intersects.length > 0) {
        let intersectedObject = intersects[0].object;
        while (intersectedObject.parent && intersectedObject.userData.shapeIndex === undefined) {
            intersectedObject = intersectedObject.parent;
        }
        const shapeIndex = intersectedObject.userData.shapeIndex;

        if (shapeIndex !== undefined && allShapes[shapeIndex]) {
            const shape = allShapes[shapeIndex];
            
            // Show tooltip
            const metrics = calculateShapeMetrics(shape);
            const content = formatShapeInfo(shape, metrics);
            tooltip.innerHTML = content;
            tooltip.style.visibility = 'visible';
            document.getElementById('elementInfoContent').innerHTML = content;
            
            // --- NEW: Update and show indicator lines ---
            if (shape.height > 0 || shape.type === 'count') {
                const boundingBox = new THREE.Box3().setFromObject(intersectedObject);
                const elementCenter = new THREE.Vector3();
                boundingBox.getCenter(elementCenter);

                const scalePosition = new THREE.Vector3(-55, -50, 0); // The position of our scale
                
                const baseElevation = shape.baseElevation || 0;
                const topElevation = baseElevation + (shape.height || 0);

                // Define points for base line
                const baseStart = new THREE.Vector3(elementCenter.x, elementCenter.y, baseElevation);
                const baseEnd = new THREE.Vector3(scalePosition.x, scalePosition.y, baseElevation);
                
                // Define points for top line
                const topStart = new THREE.Vector3(elementCenter.x, elementCenter.y, topElevation);
                const topEnd = new THREE.Vector3(scalePosition.x, scalePosition.y, topElevation);
                
                // Update line geometries
                baseElevationLine.geometry.setFromPoints([baseStart, baseEnd]);
                topElevationLine.geometry.setFromPoints([topStart, topEnd]);
                
                // Important: re-compute distances for dashed lines
                baseElevationLine.computeLineDistances();
                topElevationLine.computeLineDistances();

                // Make them visible
                baseElevationLine.visible = true;
                topElevationLine.visible = true;
            }
            
        } else { tooltip.style.visibility = 'hidden'; }
    } else { tooltip.style.visibility = 'hidden'; }
}

         // REPLACE THE ENTIRE formatShapeInfo FUNCTION
function formatShapeInfo(shape, metrics) {
    let info = `<h4>${shape.name} <span style="font-size:12px; color:#ccc;">(Layer: ${shape.layerName})</span></h4>`;
    info += `<p><strong>Description:</strong> ${shape.description || 'N/A'}</p><hr>`;

    // --- MODIFICATION START: Add Elevation Details ---
    if (shape.height && shape.height > 0) {
        const baseElevation = shape.baseElevation || 0;
        const topElevation = baseElevation + shape.height;
        info += `<p><strong>Base Elevation:</strong> ${baseElevation.toFixed(2)} m</p>`;
        info += `<p><strong>Top Elevation:</strong> ${topElevation.toFixed(2)} m</p>`;
    }
    // --- MODIFICATION END ---

    if (shape.type === 'count') {
        info += `<p><strong>Count:</strong> ${metrics.count}</p>`;
    } else if (shape.type === 'polyline' && shape.polylineType === 'sheet') {
         info += `<p><strong>Wall Area:</strong> ${metrics.surfaceArea.toFixed(2)} m²</p>`;
    } else {
        info += `<p><strong>Plan Area:</strong> ${metrics.area.toFixed(2)} m²</p>`;
        info += `<p><strong>Wall Area:</strong> ${metrics.surfaceArea.toFixed(2)} m²</p>`;
        info += `<p><strong>Volume:</strong> ${metrics.volume.toFixed(2)} m³</p>`;
    }
    info += `<p><strong>Instances:</strong> ${shape.copyCount || 1}</p>`;
    
    if (shape.rebar && metrics.rebarLength > 0) {
        info += `<hr><h4>Rebar Details</h4>`;
        info += `<p><strong>Total Length:</strong> ${metrics.rebarLength.toFixed(2)} m</p>`;
        info += `<p><strong>Total Weight:</strong> ${metrics.rebarWeight.toFixed(2)} kg</p>`;
        const sortedDiameters = Object.keys(metrics.rebarDetailsByDia).sort((a, b) => parseInt(a) - parseInt(b));
        if(sortedDiameters.length > 0) {
            info += '<ul>';
            sortedDiameters.forEach(dia => {
               info += `<li><strong>${dia}mm:</strong> ${metrics.rebarDetailsByDia[dia].length.toFixed(2)} m (${metrics.rebarDetailsByDia[dia].weight.toFixed(2)} kg)</li>`;
            });
            info += '</ul>';
        }
    }
    return info;
}
 
         function fullClear3DScene() { if (animationFrameId) cancelAnimationFrame(animationFrameId); if (!scene) return; while(scene.children.length > 0){ let c = scene.children[0]; scene.remove(c); if(c.isMesh || c.isGroup) { c.traverse(obj => { if (obj.isMesh) { obj.geometry.dispose(); if(Array.isArray(obj.material)) obj.material.forEach(m => m.dispose()); else obj.material.dispose(); } }); } } if(renderer) { if(renderer.domElement && renderer.domElement.parentElement) threeDContainer.removeChild(renderer.domElement); renderer.dispose(); } scene = null; renderer = null; controls = null; is3DMode = false; threeDContainer.style.visibility = 'hidden'; document.getElementById('elementInfoBox').style.display = 'none'; }
         function animate3D() { if (!is3DMode || !scene) return; animationFrameId = requestAnimationFrame(animate3D); controls.update(); checkIntersections(); renderer.render(scene, camera); }
         function renderAllShapesIn3D() {
    if (!scene) initialize3DScene();
    if (!scene) return; 
    
    const toRemove = scene.children.filter(c => c.userData.shapeIndex !== undefined);
    toRemove.forEach(o => scene.remove(o));

    // *** MODIFICATION: Clear existing ruler markers before redrawing ***
    const ruler = document.getElementById('verticalRuler');
    while (ruler.firstChild) {
        ruler.removeChild(ruler.lastChild);
    }
    // *** END OF MODIFICATION ***

    const allShapes = getAllVisibleShapes();
    allShapes.forEach((shape, index) => {
        addShapeTo3DScene(shape, index);
        // *** MODIFICATION: Redraw marker for each shape ***
        addRulerMarker(shape);
    });
}

/**
 * Generates stable orientation frames for a 2D path lying in the XY plane.
 * This version is robust and includes safety checks to prevent generation failures on
 * zero-length tangents or other path discontinuities.
 * @param {THREE.CurvePath} path The 2D path in the XY plane.
 * @param {number} segments The number of segments to divide the path into.
 * @returns {{tangents: THREE.Vector3[], normals: THREE.Vector3[], binormals: THREE.Vector3[]}}
 */

function addShapeTo3DScene(shape, index) {
    if (!scene || !activeDrawingName) return;
    const activeDrawing = drawings[activeDrawingName];
    const {
        pixelsPerMeter,
        img
    } = activeDrawing;

    const mat = new THREE.MeshStandardMaterial({
        color: shape.color || 0x00ff00,
        transparent: false,
        opacity: 1,
        side: THREE.DoubleSide,
        roughness: 0.8,
        metalness: 0.1
    });
    const iW = img.width || 1,
        iH = img.height || 1;
    const t3D = p2d => new THREE.Vector3((p2d.x - iW / 2) / pixelsPerMeter, -(p2d.y - iH / 2) / pixelsPerMeter, 0);
    let mesh;
    const bE = shape.baseElevation || 0;

    switch (shape.type) {
        case 'polygon':
            if (shape.points.length < 3 || !shape.height > 0) return;
            const shapePath = new THREE.Shape();
            shapePath.moveTo(t3D(shape.points[0]).x, t3D(shape.points[0]).y);
            for (let i = 1; i < shape.points.length; i++) {
                const p = shape.points[i];
                const p3d = t3D(p);
                if (p.isCurve) {
                    const cp3d = t3D({
                        x: p.cpx,
                        y: p.cpy
                    });
                    shapePath.quadraticCurveTo(cp3d.x, cp3d.y, p3d.x, p3d.y);
                } else {
                    shapePath.lineTo(p3d.x, p3d.y);
                }
            }
            if (shape.holes && Array.isArray(shape.holes)) {
                shape.holes.forEach(holeShape => {
                    if (holeShape.points && holeShape.points.length > 2) {
                        const holePath = new THREE.Path();
                        holePath.moveTo(t3D(holeShape.points[0]).x, t3D(holeShape.points[0]).y);
                        for (let i = 1; i < holeShape.points.length; i++) {
                            const p = holeShape.points[i];
                            const p3d = t3D(p);
                            if (p.isCurve) {
                                const cp3d = t3D({
                                    x: p.cpx,
                                    y: p.cpy
                                });
                                holePath.quadraticCurveTo(cp3d.x, cp3d.y, p3d.x, p3d.y);
                            } else {
                                holePath.lineTo(p3d.x, p3d.y);
                            }
                        }
                        shapePath.holes.push(holePath);
                    }
                });
            }
            const gE = new THREE.ExtrudeGeometry(shapePath, {
                depth: shape.height,
                bevelEnabled: false
            });
            mesh = new THREE.Mesh(gE, mat);
            mesh.position.z = bE;
            break;

        // PASTE THIS ENTIRE BLOCK TO REPLACE THE EXISTING 'case "shell":'
// REPLACE THE ENTIRE 'case "shell":' block in addShapeTo3DScene

// REPLACE THE ENTIRE 'case "shell":' block in addShapeTo3DScene

// REPLACE THE ENTIRE 'case "shell":' block in addShapeTo3DScene

case 'shell':
    if (!shape.points || shape.points.length < 2 || !shape.profilePoints || !shape.profilePoints.length < 2) return;

    const shellGroup = new THREE.Group();
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    const indices = [];

    const pathPoints3D = shape.points.map(p => t3D(p));
    const profilePoints2D = shape.profilePoints; // These are in meters {x, y}
    const profileVertexCount = profilePoints2D.length;

    // --- 1. Generate vertex rings for each point on the path with correct mitered orientation ---
    for (let i = 0; i < pathPoints3D.length; i++) {
        const p_curr = pathPoints3D[i];

        // Determine directions of incoming and outgoing path segments
        const p_prev = pathPoints3D[i === 0 ? 0 : i - 1];
        const p_next = pathPoints3D[i === pathPoints3D.length - 1 ? pathPoints3D.length - 1 : i + 1];

        const v_in = new THREE.Vector3().subVectors(p_curr, p_prev).normalize();
        const v_out = new THREE.Vector3().subVectors(p_next, p_curr).normalize();

        // Fix for start/end points of an open path
        if (i === 0 && !shape.isClosed) v_in.copy(v_out);
        if (i === pathPoints3D.length - 1 && !shape.isClosed) v_out.copy(v_in);

        // **THIS IS THE SHARP CORNER LOGIC**
        // We calculate the angle bisector (the miter direction) for the corner.
        // This is the "forward" direction for the profile at this specific point.
        const tangent = new THREE.Vector3().addVectors(v_in, v_out).normalize();
        if (tangent.length() === 0) { // Safety check for 180-degree turns
            tangent.copy(v_out).applyAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);
        }

        // Create the orientation frame (coordinate system) at this corner
        const up = new THREE.Vector3(0, 0, 1);
        const binormal = new THREE.Vector3().crossVectors(up, tangent).normalize(); // Profile X-axis
        const normal = new THREE.Vector3().crossVectors(tangent, binormal).normalize(); // Profile Y-axis

        // Generate the ring of vertices by placing the 2D profile into the 3D frame
        profilePoints2D.forEach(p2d => {
            const offset = new THREE.Vector3();
            // Map the profile's X/Y coordinates to the 3D frame
            offset.addScaledVector(binormal, p2d.x); // Profile X -> World Horizontal
            offset.addScaledVector(normal, p2d.y);   // Profile Y -> World Vertical
            
            // **THIS IS THE CENTER LINE LOGIC**
            // The final vertex is the path point (p_curr) + the profile offset.
            // This places the (0,0) origin of the profile directly on the 2D path.
            const finalVertex = p_curr.clone().add(offset);
            vertices.push(finalVertex.x, finalVertex.y, finalVertex.z);
        });
    }

    // --- 2. Generate faces for the sides of the shell by connecting the vertex rings ---
    const numPathSegments = shape.isClosed ? pathPoints3D.length : pathPoints3D.length - 1;
    for (let i = 0; i < numPathSegments; i++) {
        for (let j = 0; j < profileVertexCount; j++) {
            const next_j = (j + 1) % profileVertexCount;
            const next_i = (i + 1) % pathPoints3D.length;

            // Get indices for the four corners of the panel
            const a = i * profileVertexCount + j;
            const b = i * profileVertexCount + next_j;
            const c = next_i * profileVertexCount + j;
            const d = next_i * profileVertexCount + next_j;

            // Create two triangles for the panel
            indices.push(a, b, c);
            indices.push(b, d, c);
        }
    }
    
    // --- 3. Generate faces for the end caps to make the shell solid (if not a closed loop) ---
    if (!shape.isClosed && profileVertexCount > 2) {
        // Use a built-in utility to triangulate the profile shape
        const profileShapePoints = profilePoints2D.map(p => new THREE.Vector2(p.x, p.y));
        const triangles = THREE.ShapeUtils.triangulateShape(profileShapePoints, []);
        
        // Create the start cap
        const startCapOffset = 0;
        for (const tri of triangles) {
            indices.push(startCapOffset + tri[0], startCapOffset + tri[1], startCapOffset + tri[2]);
        }
        
        // Create the end cap (with reversed vertex order to face outwards)
        const endCapOffset = (pathPoints3D.length - 1) * profileVertexCount;
        for (const tri of triangles) {
            indices.push(endCapOffset + tri[0], endCapOffset + tri[2], endCapOffset + tri[1]);
        }
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    geometry.setIndex(indices);
    geometry.computeVertexNormals(); // For correct lighting

    const shellMesh = new THREE.Mesh(geometry, mat);
    shellGroup.add(shellMesh);

    mesh = shellGroup;
    mesh.position.z = bE; // Apply the base elevation
    break;


        case 'variablePolygon':
            if (shape.points.length < 3) return;
            const geom = new THREE.BufferGeometry();
            const vertices_vp = [];
            const indices_vp = [];
            const numPoints = shape.points.length;
            const bottomPoints = shape.points.map(p => t3D(p));
            const topPoints = shape.points.map(p => {
                const baseVec = t3D(p);
                return new THREE.Vector3(baseVec.x, baseVec.y, p.z);
            });
            bottomPoints.forEach(p => vertices_vp.push(p.x, p.y, 0));
            topPoints.forEach(p => vertices_vp.push(p.x, p.y, p.z));
            for (let i = 1; i < numPoints - 1; i++) {
                indices_vp.push(0, i + 1, i);
            }
            for (let i = 1; i < numPoints - 1; i++) {
                indices_vp.push(numPoints, numPoints + i, numPoints + i + 1);
            }
            for (let i = 0; i < numPoints; i++) {
                const next = (i + 1) % numPoints;
                const p1 = i;
                const p2 = next;
                const p3 = i + numPoints;
                const p4 = next + numPoints;
                indices_vp.push(p1, p2, p3);
                indices_vp.push(p2, p4, p3);
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices_vp, 3));
            geom.setIndex(indices_vp);
            geom.computeVertexNormals();
            mesh = new THREE.Mesh(geom, mat);
            mesh.position.z = bE;
            break;

        case 'circle':
            if (!shape.center || !shape.radius > 0 || !shape.height > 0) return;
            const rR = shape.radius / pixelsPerMeter;
            const gC = new THREE.CylinderGeometry(rR, rR, shape.height, 32);
            gC.rotateX(Math.PI / 2);
            mesh = new THREE.Mesh(gC, mat);
            const c3D = t3D(shape.center);
            mesh.position.set(c3D.x, c3D.y, bE + shape.height / 2);
            break;
        case 'polyline':
            if (shape.points.length < 2) return;
            if (shape.polylineType === 'sheet') {
                if (!shape.height > 0) return;
                const wallVertices = [];
                const pointsMeters = shape.points.map(p => new THREE.Vector2((p.x - iW / 2) / pixelsPerMeter, -(p.y - iH / 2) / pixelsPerMeter));
                const height = shape.height;
                const baseElevation = shape.baseElevation || 0;
                for (let i = 0; i < pointsMeters.length - 1; i++) {
                    const p1 = pointsMeters[i];
                    const p2 = pointsMeters[i + 1];
                    const v1 = new THREE.Vector3(p1.x, p1.y, baseElevation + height);
                    const v2 = new THREE.Vector3(p2.x, p2.y, baseElevation + height);
                    const v3 = new THREE.Vector3(p1.x, p1.y, baseElevation);
                    const v4 = new THREE.Vector3(p2.x, p2.y, baseElevation);
                    wallVertices.push(v3.x, v3.y, v3.z, v2.x, v2.y, v2.z, v1.x, v1.y, v1.z);
                    wallVertices.push(v3.x, v3.y, v3.z, v4.x, v4.y, v4.z, v2.x, v2.y, v2.z);
                }
                const wallGeom = new THREE.BufferGeometry();
                wallGeom.setAttribute('position', new THREE.Float32BufferAttribute(wallVertices, 3));
                wallGeom.computeVertexNormals();
                mesh = new THREE.Mesh(wallGeom, mat);
            } else if (shape.polylineType === 'pipe') {
                if (!shape.diameter > 0 || shape.points.length < 2) return;
                const pipeGroup = new THREE.Group();
                const pipeRadius = shape.diameter / 2;
                const points3D = shape.points.map(p => new THREE.Vector3((p.x - iW / 2) / pixelsPerMeter, -(p.y - iH / 2) / pixelsPerMeter, p.z || 0));
                for (let i = 0; i < points3D.length - 1; i++) {
                    const startPoint = points3D[i];
                    const endPoint = points3D[i + 1];
                    if (startPoint.distanceTo(endPoint) < 0.001) continue;
                    const path = new THREE.LineCurve3(startPoint, endPoint);
                    const tubeGeom = new THREE.TubeGeometry(path, 1, pipeRadius, 8, false);
                    const segmentMesh = new THREE.Mesh(tubeGeom, mat);
                    pipeGroup.add(segmentMesh);
                }
                points3D.forEach(point => {
                    const sphereGeom = new THREE.SphereGeometry(pipeRadius, 8, 8);
                    const sphereMesh = new THREE.Mesh(sphereGeom, mat);
                    sphereMesh.position.copy(point);
                    pipeGroup.add(sphereMesh);
                });
                mesh = pipeGroup;
            }
            break;
        case 'count':
            if (shape.points.length < 1) return;
            const countGroup = new THREE.Group();
            const countGeom = new THREE.SphereGeometry(0.2, 16, 16);
            shape.points.forEach(p => {
                const countMesh = new THREE.Mesh(countGeom, mat);
                const p3d = t3D(p);
                countMesh.position.set(p3d.x, p3d.y, bE);
                countGroup.add(countMesh);
            });
            mesh = countGroup;
            break;
    }
    if (mesh) {
        mesh.userData.shapeIndex = index;
        scene.add(mesh);
        shape._3DObject = mesh;
    }
}
         // Add this new function inside your <script> tag

function setupSmmControls() {
    const dbSelect = document.getElementById('smmDbSelect');
    const loadBtn = document.getElementById('loadSmmDbBtn');
    const statusText = document.getElementById('smmDbStatus');

    // 1. Fetch the list of available databases from the server
    const populateDbList = async () => {
        try {
            const response = await fetch('http://localhost:3000/api/list-databases');
            const dbFiles = await response.json();
            dbSelect.innerHTML = '<option value="">Select a Database...</option>';
            dbFiles.forEach(file => {
                const option = document.createElement('option');
                option.value = file;
                option.textContent = file;
                dbSelect.appendChild(option);
            });
        } catch (error) {
            console.error('Could not fetch database list:', error);
            statusText.textContent = 'Server Offline';
        }
    };

    // 2. Handle the "Load DB" button click
    loadBtn.addEventListener('click', async () => {
        const selectedDb = dbSelect.value;
        if (!selectedDb) {
            customAlert("Please select a database file from the list.");
            return;
        }

        statusText.textContent = 'Connecting...';
        statusText.style.color = '#ff9800';

        try {
            const response = await fetch('http://localhost:3000/api/load-database', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fileName: selectedDb })
            });

            const result = await response.json();

            if (response.ok) {
                statusText.textContent = `Connected: ${selectedDb}`;
                statusText.style.color = '#4CAF50'; // Green for success
            } else {
                throw new Error(result.message);
            }
        } catch (error) {
            statusText.textContent = 'Connection Failed';
            statusText.style.color = '#f44336'; // Red for failure
            customAlert(`Error: ${error.message}`);
        }
    });

    // Initial population of the list when the app starts
    populateDbList();
}

         // --- Project Save/Load and MATLAB Export ---
       async function saveProject() {
    if (Object.keys(drawings).length === 0) {
        customAlert("Nothing to save.");
        return;
    }

    // --- MODIFICATION START ---
    // 1. Prompt the user for a file name using your existing customPrompt function.
    const fileName = await customPrompt("Save Project", "Enter a file name (without extension):", "project");

    // 2. If the user cancels or enters nothing, stop the save process.
    if (!fileName || fileName.trim() === '') {
        customAlert("Save cancelled.");
        return;
    }
    
    // 3. Create the full file name with the correct .q3d extension.
    const fullFileName = `${fileName.trim()}.q3d`;
    // --- MODIFICATION END ---

    // Create a serializable version of the drawings object
    const serializableDrawings = {};
    for (const name in drawings) {
        // Important: Don't try to save the 'img' element directly. Save its 'src' (the data URL).
        const { img, ...rest } = drawings[name]; 
        serializableDrawings[name] = {
            ...rest,
            dataURL: img.src 
        };
    }

    const projectState = {
        drawings: serializableDrawings,
        activeDrawingName: activeDrawingName,
    };

    const jsonString = JSON.stringify(projectState, null, 2);
    const blob = new Blob([jsonString], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    
    // --- MODIFICATION ---
    // 4. Use the user-provided file name for the download.
    a.download = fullFileName; 
    // --- MODIFICATION ---

    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // --- MODIFICATION ---
    // 5. Update the confirmation message to show the new name.
    customAlert(`Project saved as ${fullFileName}`);
    // --- MODIFICATION ---
}
        function loadProject(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const state = JSON.parse(e.target.result);
            fullClear3DScene(); // Clear the 3D view
            
            drawings = {}; // Reset drawings object
            
            const drawingNames = Object.keys(state.drawings);
            if (drawingNames.length === 0) {
                // Handle case with no drawings
                addNewDrawing('Default Drawing', '');
                customAlert("Project loaded, but it contained no drawings.");
                return;
            }

            let drawingsToLoad = drawingNames.length;

            for (const name in state.drawings) {
                const savedDrawing = state.drawings[name];
                const image = new Image();
                
                // Assign properties before setting src
                drawings[name] = { ...savedDrawing, img: image };
                // Delete the dataURL property as we now have the img object
                delete drawings[name].dataURL; 

                image.onload = () => {
                    drawingsToLoad--;
                    if (drawingsToLoad === 0) {
                        // Once all images are loaded, switch to the active drawing
                        switchDrawing(state.activeDrawingName || drawingNames[0]);
                        customAlert("Project loaded successfully.");
                    }
                };
                image.onerror = () => {
                    drawingsToLoad--;
                    console.error(`Error loading image for drawing: ${name}`);
                    if (drawingsToLoad === 0) {
                        switchDrawing(state.activeDrawingName || drawingNames[0]);
                        customAlert("Project loaded, but some images failed to load.");
                    }
                };
                image.src = savedDrawing.dataURL;
            }

        } catch (err) {
            customAlert("Failed to load project file. It may be corrupted.");
            console.error("Load project error:", err);
        }
    };
    reader.readAsText(file);
    event.target.value = ''; // Reset file input
}

        function exportToMatlab() {
            const allShapes = getAllVisibleShapes();
            if (allShapes.length === 0) {
                customAlert("No elements to export.");
                return;
            }

            let script = `% MATLAB Data Export from 3D Quantifier\n`;
            script += `% Generated on: ${new Date().toUTCString()}\n\n`;
            script += `clear elements;\n\n`;
            script += `elements = struct('Name', {}, 'Layer', {}, 'Type', {}, 'Length_m', {}, 'Area_m2', {}, 'Volume_m3', {}, 'WallArea_m2', {}, 'Count', {});\n\n`;

            allShapes.forEach((shape, i) => {
                const metrics = calculateShapeMetrics(shape);
                script += `elements(${i+1}).Name = '${shape.name.replace(/'/g, "''")}';\n`;
                script += `elements(${i+1}).Layer = '${shape.layerName.replace(/'/g, "''")}';\n`;
                script += `elements(${i+1}).Type = '${shape.type}';\n`;
                script += `elements(${i+1}).Length_m = ${metrics.length.toFixed(4)};\n`;
                script += `elements(${i+1}).Area_m2 = ${metrics.area.toFixed(4)};\n`;
                script += `elements(${i+1}).Volume_m3 = ${metrics.volume.toFixed(4)};\n`;
                script += `elements(${i+1}).WallArea_m2 = ${metrics.surfaceArea.toFixed(4)};\n`;
                script += `elements(${i+1}).Count = ${metrics.count};\n\n`;
            });
            
            script += `fprintf('Successfully loaded %d elements into the "elements" struct.\\n', length(elements));\n`;
            script += `T = struct2table(elements);\n`;
            script += `disp('Data is also available as a table "T".');\n`;

            const blob = new Blob([script], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'quantifier_data.m';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

// REPLACE the existing 'load' event listener with this one
window.addEventListener('load', () => {
    const splash = document.getElementById('splashScreen');
    const bar = document.getElementById('progressBar');
    const splashBg = document.getElementById('splash-background');
    const splashMessage = document.getElementById('splashMessage');

    // List of high-quality construction images. Replace with your own if you like.
    const images = [
        'https://images.pexels.com/photos/159306/construction-site-build-construction-work-159306.jpeg',
        'https://images.pexels.com/photos/2219024/pexels-photo-2219024.jpeg',
        'https://images.pexels.com/photos/1216589/pexels-photo-1216589.jpeg',
        'https://images.pexels.com/photos/316093/pexels-photo-316093.jpeg'
    ];
    
    const messages = [
        "Initializing Engine...",
        "Loading Modules...",
        "Calibrating Quantifiers...",
        "Finalizing Workspace..."
    ];

    let imageIndex = 0;
    let messageIndex = 0;

    // Preload the first image
    splashBg.style.backgroundImage = `url('${images[imageIndex]}')`;
    splashBg.style.opacity = 1;
    splashMessage.textContent = messages[messageIndex];

    const imageTimer = setInterval(() => {
        imageIndex = (imageIndex + 1) % images.length;
        splashBg.style.opacity = 0; // Fade out
        setTimeout(() => {
            splashBg.style.backgroundImage = `url('${images[imageIndex]}')`;
            splashBg.style.opacity = 1; // Fade in new image
        }, 1000); // Wait for fade out to complete
    }, 4000); // Change image every 4 seconds

    const messageTimer = setInterval(() => {
        messageIndex = (messageIndex + 1) % messages.length;
        splashMessage.textContent = messages[messageIndex];
    }, 1000);

    // Progress bar animation
    setTimeout(() => { bar.style.width = "100%"; }, 100);

    // Hide splash screen after animation
    setTimeout(() => {
        clearInterval(imageTimer);
        clearInterval(messageTimer);
        splash.style.opacity = '0';
        setTimeout(() => {
            splash.style.display = 'none';
            setup(); // Call main setup after splash screen is hidden
        }, 800); // Wait for fade-out transition
    }, 4000);
});

// Confirm before leaving the page
window.addEventListener('beforeunload', (e) => {
    e.preventDefault();
    e.returnValue = 'Are you sure you want to leave? Your changes may not be saved.';
});

</script>
 </body>
 </html>